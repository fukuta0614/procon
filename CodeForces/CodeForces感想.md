

## div2

### Round 641
https://codeforces.com/contest/1350

- A Orac and Factors
    - 概要
        - f(n) = nの約数の最小値 (1以外)
        - g(i+1) = g(i) + f(g(i))
        - g(0) = n
        - g(K)を求める
    - 解法
        - nが偶数なら、f(n)=2
        - nが奇数なら、f(n)=(約数の最小値)
            - また、f(n)は奇数なので、n+f(n)は偶数になる
        - つまり、g(1)はもう偶数なので、そこから2たされるだけ             
        
- B Orac and Models
    - 概要
        - N個の配列S, N<1e5
        - この中から、いくつかの要素を選ぶ
        - 選ぶとき、i_jがi_{j+1}の約数 かつ S[i_j] < S[i_{j+1}]となるように選ぶ
            - パット見わからんかったが、Sの3番目の要素を選んだら、次は3*k番目の要素で、かつS[3*k]がS[k]より大きい、ようなものを選ぶ
        - 選べる要素の数の最大値            
    - 解法
        - 約数の数は√Nで抑えられるので、
        - i番目を選んだときに、その前に選ぶ要素としてありうるものを全部見て最大取るだけ
        - dp[i] = max(dp[j]) + 1（j=iの約数)
    
- C Orac and LCM
    - 概要
        - 要素Nの集合 A
        - lcm(A[i], A[j]) の　nC2の組み合わせ分の集合B
        - 集合Bのgcd
    - 解法
        - いつもどおり主客転倒で、ある素因数dがgcdに含まれるのはどういうときか
            - すべてのA[i], A[j]でdを含んでいる必要がある
            - 集合Nの中で、dを持たない数が2つあったら(x,yとする)、lcm(x,y)はdを含まない
            - 逆に、dを含まないやつが一個なら、A[i], A[j]のどちらかは必ずdを含むので、lcmもdを含む
        - つまり、N-1個拾ってきた集合のgcdは、最後のgcdに含まれる
        - また、要素が3つだったとして、
            - gcd(1,2)=2, gcd(1,3)=4, gcd(2,3)=3だったら、
            - これらの掛け算ではなくこれらのlcmになりそうなことがわかる
        - 結局、i番目の要素を選ばなかった場合のgcd(i)をi=1~Nまで計算して、
        - gcd(i)のlcmが答え
        - i番目の要素を選ばなかった場合のgcd(i)は
            - gcd(gcd(0..i-1), gcd(i+1, N)) で計算できるので、
            - 左右から累積gcdを計算しておけば、O(N)でいける                        
        
- D Orac and Medians
    - 概要
        - N個の配列A
        - 操作
            - l,rを選んで、A[l..r]の要素をA[l..r]のmedianに置換する
        - この操作を任意の回数行って、Aの要素をすべてKにできるかどうかの判定
        
    - 解法
        - K, Kが2個並んでれば、K,K,aのmedianはaによらずにKなので、全部Kにできる
        - 最初、「medianがKになるようなl,rの選び方はあるか」を解こうとした
            - median of mediansみたいな感じで、K以上で+1, 未満で-1の累積和をとったりしてみたけど、
            含まれるKの数によってmedianがKになる条件が変わるので、難しかった
            - 例えばK=3のとき、
                - 1 3 4 5 6 7 sum = 4
                - 1 3 3 3 3 3 sum = 4 だけどmedianは3
        - けど、無理だったので再考
        - 実は、K, K+1が並んでても、そこからK, Kを作れるので、さっきのように全部Kにできる
        - また、K+1が並んでれば、Kのあるところまで全部K+1にできる
        - つまり、「medianがK以上なるようなl,rの選び方はあるか」
            - これなら、median of mediansのかんたん版
            - 実装かえるのめんどかったので、有無判定だけで十分だけど、
            - BIT使ってl,rの組み合わせの数を数える実装にした。
        - これでOK！
        
    - 他の人の解法
        - K以上のmedianがあるかどうかってもっと簡単に求まりそうだなとは思ったものの諦めたところ
        - medianを調べるのは、長さ3までで十分
            - K以上を+1, 未満を-1とする
            - 長さ2,3で、和が0より大きくならないということは、少なくとも+1と+1の間に-1が2個あるということ
            - つまり、一番惜しいやつでも、+1,-1,-1,+1なので、これの和は0。つまり2,3でだめなのに4以上でいけることはない。        
        - 2,3を全部ぴーってみていけば良いらしい。頭良いなぁ         
         
- E Orac and Game of Life
    - 概要
        - NxMのマスに黒白が塗られている 
        - 自分のマスの上下左右に、自分と同じ色があったら反転
        - k回目のi, jの色を求める
    - 解法
        - 一回反転したら、その後毎回反転することがわかる
            - ある点xが反転したってことは、周りと同じ色の点yがいたってこと。
            - また、yも同様に、xは同じ色のはずなので、お互い同じ色のまま、反転を続ける
        - また、反転する状態は、1世代で1マスずつ伝播する
            - 反転しない状態のやつの周りのマスのどれかが反転したら、次の世代で、そいつは反転状態になる
        - つまり、最初から反転状態のやつからの距離分の世代後、そいつは反転状態になる
        - これは、膨張処理みたいに、queueで距離0のやつを突っ込んで、bfsっぽく広げていけば良い。
        - Dよりかんたんだった気がするけど嬉しい。                         
        
- F Slime and Sequences (Easy Version)
    - 概要
    - 解法
