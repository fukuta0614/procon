# 蟻本！！

## aribon 2-1 すべての基本 "全探索"

### 例題 2-1-1　部分和問題
- asdf

### 例題 2-1-2 dfs
- Lake Counting (POJ No.2386)
    - ラベリング
    - dfsするだけ
    
### 例題 2-1-3　bfs
- ARC 005 C 器物損壊！高橋君
    - 2回だけ壁を壊すことができる迷路。到達可能性を答える
    - 壁を超えるときはコスト1、それ以外コスト0とするグラフとすると、
    - ダイクストラで最短経路が2以下なら答え。
    - コストが0,1しかないなら、コスト0のときはdequeの先頭、コスト1のときはdequeの末尾、
    とするだけで常に最短経路を辿れる。
    - 0-1 bfsと呼ばれるらしい。
    - 壊したどうかのフラグをもってダイクストラでもいける

### 例題 2-1-4 n!全探索
- ABC 054 C One-stroke Path
    - 巡回セールスマンとしてN^2 2^Nでもとける
    
## aribon 2-2 猪突猛進！ "貪欲法"

### 例題 2-2-1　
- 特になし

### 例題 2-2-2　区間スケジューリング問題
- ABC 103 D - Islands War
    - 一列の島に橋がかかっていて、a_i,b_i番目の島が行き来できないように橋を落とす。壊す橋の最小。
    - 気づきづらいが区間スケジューリング
    - bでソートして貪欲
    
- Codeforces 296 DIV1 B Clique Problem
    - 最大クリーク問題もどき
        - クリーク：任意の二頂点間に枝があるような頂点集合
    - 位置x, 重みwがあり、|x_i - x_j| >= |w_i - w_j|なら辺をはる
    - 遠ければ辺がはられる、直感と逆の設定
    - 各点が x_i - w_i ~ x_i + w_iに広がると考えると、それぞれが重ならなければ辺がある
    - つまり、区間が重ならないように選んだと木の最大数 -> 区間スケジュール
 
### 例題 2-2-3 辞書順
- asdf

### 例題 2-2-4 
- ABC 091 C 2D Plane 2N Points　
    - 最大フローでも解ける
    - 考えると、最適な組み合わせがわかる mada
    
### 例題 2-2-5 priority_queue
- Codeforces 263 DIV2 C Appleman and Toastman
    - x,yを取り出して(x+y)/2を入れる。 mada
    
## aribon 2-3 値を覚えて再利用 "動的計画法"

### 例題 2-3-1　01ナップサック問題
- asdf

### 例題 2-3-2　最長共通部分列問題
- asdf

### 例題 2-3-3　個数制限なしナップサック問題
- asdf

### 例題 2-3-4
- 高橋くんゲーム  
    - 基本的には0-1ナップザックの価値でdpして重みの最小値を求めていくタイプと一緒。  
    - 問題の指定はちょうどK回という制約があるが、実際にはK回以下でn日勝率upできるなら、K回でも達成できること。
    - 肝は、一回負けて以降、全勝すればK回になる。（分母が大きくなれば勝率は上がる）

## 例題 2-3-5
- D - Many Go Round  
    - 個数制限DP。一周するので配列再利用ができない。

- フクロモモンガ  
    - 普通にダイクストラでやってしまった。何がDPかまだわからず。  
    - あみだとは違い、どこからでも移動できるので最適な移動が簡単に決まる。  
    - とりあえず下まで降りていって、降りられなくなったらその分登る。
    - そうすると、結局ある地点まで最短時間でたどり着くやつがえらいので、それをコストにダイクストラ  

- Bichrome Tree  
    - 面白かった。
    - 結局、自分の子供の、自分の色じゃない方の和は小さいほどよいので、
    - 取りうる組み合わせの和のなかで最小値を求めれば良い。  
    - その取りうる組み合わせが最悪2^Nになるので、DPで求める。

- 注文の多い高橋商店  
    - mada

### 例題 2-3-6
- インラインDP  
NQのdpテーブル更新が必要に見えるが、実際にはQ回行う更新ではNの中の一箇所しか更新しない場合、
logN・Qに落とせること。  
LISはある長さの最長増加部分列の最後尾の数だけ更新すれば良くて、それが二部探索でlogNで探せる。的な


### 例題 2-3-7
- 写像12相  
    - N個のボールを、K個の箱に入れる組み合わせで、  
    - Nを区別するか、Kを区別するか、(条件あり、単射、全射）の12個の組み合わせのこと  
    - その中に、スターリング数、ベル数、分割数がある

- 分割数  
    - 正の整数nをm分割するときの場合の数。  
    - dp[i][j] : jのi分割
    - 0を一つでも含むときdp[i-1][j]と、0を含まないときdp[i][j-i]の和

- Kill/Death  
    - dp[i][j] : i番目まで見たときの、総和がjとなる組み合わせ  
    - dp[i+1][j+sm] = dp[i][j] * (smのグループ人数 分割)) これのsmのiteration   
    - すごい解法: https://kimiyuki.net/writeup/algo/atcoder/dwacon2018-prelims-c/

## aribon 2-4 データを工夫して記憶する "データ構造"

### 例題 2-4-1 priority_queue
- ABC 062 D - 3N Numbers
    - asdf

### 例題 2-4-2　二分探索木
- asdf

### 例題 2-4-3 UnionFind
- 食物連鎖 (POJ No.1182)
    - すげえむずい mada
    
- ABC 087 D People on a Line
    - 重み付きUnionFind
    
## aribon 2-5 あれもこれも実は "グラフ"

### 例題 2-5-1　二部グラフ判定
- asdf

### 例題 2-5-2 ダイクストラ
- asdf

### 例題 2-5-3 最小全域木
- asdf

### 例題 2-5-4 ベルマンフォード
- asdf

### 例題 2-5-5 わーシャルフロイド
- asdf

## aribon 2-6 数学的な問題を解くコツ

### 例題 2-6-1 最大公約数
- asdf

### 例題 2-6-2 拡張ユークリッドの互除法
- asdf

### 例題 2-6-3 素数系
- asdf

### 例題 2-6-4 素数　応用
- asdf

### 例題 2-6-5 素数　応用
- asdf

### 例題 2-6-6 繰り返し二乗法
- asdf


## aribon 3-1 値の検索だけじゃない！ "二分探索"

### 例題 3-1-1
- ARC 037 C 億マス計算 
    - 解xを仮定して、部分問題を解く。部分問題に適合するxの最小（最大）値が最終的な解になる。 というパターン
    - 部分問題の判定が、あるxを境に１回だけ変化するような場合、二分探索で高速に解を探索できる。
      
    - 数列の中のK番目の値 -> 数列の中で x より小さい数がK個以上あるような xの中の最小値
    - 部分問題として、さらに二分探索が必要


### 例題 3-1-2
- asdf

### 例題 3-1-3
- JOI 2013 本選 C バームクーヘン
    - xが最小値になりうるか
    - xを超える切り方のうち最小の切り方で２つ切り出したとき、残りの1つがxを超えていればOK
    
### 例題 3-1-4
- ARC 060 C 高橋君とカード
    - N枚のカードを複数選んで平均がちょうどAになるような選び方
    - 各カードからAを引いて和が0になるような選び方にする
    - dp[i][j] = i番目まで使うとき、和がjになるような選び方の総数 
    
- ARC075 E - Meaningful Mean
    - median of mediansの部分問題
    - Al ~ Arの平均値がK以上 ⇒ Bl ~ Brの和が0以上 (Bi = Ai - K)
    - Bl ~ Brの和が0以上 ⇒ Cr - Cl ≧ 0 (Ci = B0 ~ Biの和）
    - Ciの数列で、Ci ≦ Cj となるような i, j の組み合わせの数 ⇒ 転倒数 
    - 転倒数はBITでNlogNで求めることができる。
    - std::sortは安定ソートでないため、順序を変えたくなかったらstable_sortを使う
    
## aribon 3-2 厳選！頻出テクニック

### 例題 3-2-1 しゃくとり 
- ARC 098 D Xor Sum 2
    - A_l + ... + A_r = A_l xor ... xor A_r　となる連続部分列の数
    - 和とxorが一致するのは、bitごとにみたときに1が複数立たないとき
    - lからrまで見て成り立っていればその中の連続部分列は全部OK
    - つまり尺取法
 
### 例題 3-2-2 しゃくとり応用
- ABC 033 D 三角形の分類
    - １点を決めてnC2の三角形を調べる。これをn点分繰り返す。
    - 鈍角と直角の数だけ管理して、鋭角は最後に全体から鈍角と直角を引く。
    - （鈍角、直角はダブルカウントすることがないため）
    - ある辺を決めたら、角度の差θとして θ==90, 90<θ<180となる辺を数えればよい。
    - 角度でソートすると、角度の差が単調増加になるので二分探索か尺取り法が使える。
    - 尺取り法はi,l,rの変数が必要なのでやや面倒。
    
### 例題 3-2-3 ライツアウト
- ABC 083 D Wide Flip
    - 意外とむずかった
    - 左からk番目の数は、左からk個反転させてからk-1個反転させれば自由に操作できることがわかる
    - ひっくり返さなきゃいけないもののなかで、左右から一番遠いものを求めたら答え。
    

### 例題 3-2-4 ライツアウト応用
- AOJ 1308 Awkward Lights
    - マンションのある部屋のスイッチを消すと、マンハッタン距離Dの部屋のon/offが変化
    - 同じ部屋のスイッチを二回押す必要はなく、スイッチを押す順は関係ない
    - 連立方程式

### 例題 3-2-5 弾性衝突
- SRM 458 DIV1 Easy BouncingBalls
    - ボールは通り抜けるだけ、と考えれば通り抜ける数を数えれば終わり。

### 例題 3-2-6 半分全列挙
- ダーツ
    - N個の配列から4つ取り出したときの和のM以下の最大値
    - 2つ取り出した場合の取りうる値を保持してにぶたん

### 例題 3-2-7 半分全列挙 応用
- AGC 026 C - String Coloring
    - 2Nの文字列のうちNを青色、Nを赤色に塗り分けたとき、青と赤の文字列が一致するような塗り方の組み合わせ
    - 左半分のNの青と赤の分割方法、右半分のNの青と赤の分割方法、それぞれ2^N通りを列挙して辞書につっこんで、突き合わせる
    - ABC 049 D 連結にやや似てる
    

### 例題 3-2-8 座標圧縮
- 領域の個数
    - 疎なかたまりがあるような二次元座標でラベリング
    - 何もないところを圧縮
    - 1234 789となっていたとき、56のところになにもないからといって7を5まで圧縮すると
   つながってしまうので、はじっこの±1分は圧縮しないよう気をつける
  
- JOI 2008 予選 E シャッフル
    - 山札があって、a,bのクエリをもらったら上からa枚目までと、b+1枚目から一番下までを交換する
    - 例題とはちょっと様子が違うけど、10枚で3,5のクエリなら、
    - [1,10] -> [1,3],[4,5],[6-10] -> [6-10],[4,5],[1,3]
    - みたいな感じで、分割して、シャッフルする、みたいな感じ

## aribon 3-3 BITとセグ木

### 例題 3-3-1 セグ木
- Crane  
    - むずい。コードは理解はしたがこれじゃないといけないのかわかってない

- タコヤキオイシクナール  
    - 良問。f(x) = ax+b, g(x) = cx + d -> f・g(x) = (ac)x + b+ad なのでモノイド

- JOI 2011 春合宿 day4-2 本棚  
    - 昇順にするには、増加部分列を見つけてそれ以外を動かせば良い。  
    - 動かすやつの重さの和が小さければ良いので、最大重み増加部分列を求める  
    - 末尾がxのときの最大の重みを計算できればよく、[a,b)のmaxが計算できればOK

### 例題 3-3-2 BIT
- ARC 088 E Papple Sort  
    - 文字列を回文にするためのスワップ回数  
    - 最終的に左側に来る必要があるか右側に来る必要があるかは確定している。
    - 肝は、左側を1回swap, 右側を1回swapしてできるなら 右側を2回swapでできるので、
    左側は動かす必要ないため、左側の最終状態も確定する。  
    - 右側を左側にするためのswap回数 -> 転倒数カウントでOK

### 例題 3-3-3 遅延セグ木

- AOJ Course RSQ and RAQ  
    - 区間addと区間sum。
    - 遅延セグ木で簡単だが、伝播させなくてもできる。(区間addが可換だから)

- AOJ Course RMQ and RAQ  
    - 区間addと区間max。Starry Sky Tree。
    - 遅延セグ木で簡単だが、伝播させなくてもできる。(区間addが可換だから)

### 例題 3-3-4 平方分割
- K-th Number (POJ No.2104)  
    - 配列の区間[a,b)の小さい方からk番目の数を答えるクエリを高速に
    - 平方分割
        - 各バケットごとにソートしておく。各バケット内にxより小さい数が何個あるかはにぶたんでいけて、
        xをにぶたんすればok。はみ出した部分はソート前のoriginal配列で線形探索。
    - RangeTreeでもいける
        - 各ノードはマージソートしたときの中間結果(配列)を保持しているイメージ。
        - 区間[a,b)を上から見てひっかかったノードでにぶたんすれば、xより小さい数を数えられる  
        -> 二次元座標でl<=x<rでかつ y<tなる点の数を数えることも可能
- ARC 033 C データ構造
    - 集合にxを追加, x番目に小さい数を求めて集合から削除　のクエリを高速に
    - aがはいる箱を用意して、aが追加されたらa番目を+1するほうが楽
    - 平方分割なら、箱を分割して箱ごとに今何個入っているかも管理すれば楽。       

## 3-4 bitDP, 行列累乗, インラインDP
### 3-4-1, 3-4-2 巡回セールスマン問題, bitDP

- 概要
    - O(N!)に見える問題でも、訪れた順序や選んだ順序に関係なくDPを行えるなら、bitDPで O(N 2^N)にできる、という話

- 組み合わせ列挙
    - {0, 0, 0, 1, 1, 1} なるvectorでnext_permutation
    - 蟻本p144のかっこいいやつ

- ABC 041 D 徒競走
    - 概要
        - 誰より誰のほうが着順が早かった、という情報がいくつかある
        - その情報に矛盾しないような着順は何通りあるか
    - 解法
        - トポロジカルソートの数え上げ
        - dp[S] = 頂点集合Sのトポロジカルソートの数えあげ。
        - Sの前にvがおけるためには、v->uとなるuがSに存在しないこと
        - 配るDPで、Sに対してvを追加出来たらdp[S U v] += dp[S]でいける。
      
- ABC 025 D 25個の整数
    - 概要
        - 25個のマスに、1~25の数字を埋める。
        - 横、縦に連続するどの3マスも昇順、降順にならないように埋める通りの数。
        - いくつかのマスにはあらかじめ数字が埋まっている。
    - 解法
        - 小さいほうから数を埋めていくことを考える。
        - ここで、昇順、降順の話は実際の数字ではなく大小だけが大事。
        - 小さいほうから埋めていく、という仮定をするなら何が埋まっていようと今から埋める数字は埋まっている数字より大きく、まだ埋まっていないところに埋まる数字は、今埋めるやつより大きい
        - この仮定から、各マスが埋まっているかいないかの状態だけ管理すればよく、2^25通りの状態に対して、空いているところに今考えている数字を埋められルカを考えればよい。
        - 今考えている数字、というのは埋まっているマスの数でわかる。
        - あらかじめ埋まっている数字は埋める場所が確定しているというだけ。
        - 今３連続じゃなくても、二個昇順、降順が続くだけであとでだめになるから足さない、という遷移になっているのが大事。
        
### 3-4-3 sliding bit DP

- 概要
    - DPで見る状態に応じて、見るマスの場所が変わっていくイメージのDP

- TDPC Q 連結
    - 概要
        - 0,1からなる文字列がN個ある。
        - これらを連結してできる長さLの文字列の通り。
        - 文字列が同じなら連結方法は問わない。
        - 文字列は複数利用可能
    - 解法
        - dp[i][j][k]
            - i文字まで伸ばしたときの
            - 直近7文字がjで、
            - 直近8文字のなかで文字列の切れ目となるような場所にはbitがたつような数を作るとk となるような数
        - むずい
        - 01, 10, 0110, があったとして、0110をダブルカウントしてはいけないので、使える文字列ベースで考えるのではなく、できうる文字列ベースで考える必要がある
        - 切れ目を管理するだけで次に何を伸ばせるかが確定できるのがすごい。
    
### 3-4-4 行列累乗

- ARC 050 C LCM 111


## 3-5 最大流

### 3-5-1 最大フロー最小カット
- 理解
    - s-tカット = sからtへ向かう辺がなくなるように辺を選んだ時の集合
    - カットの容量 = カットで選んだ辺の容量の和
    - ford-fulkurson (最大フロー = 最小カットとなる理由)
        - 気持ちとしては、一度最適でない経路に水を流してしまっても，逆向きに流した水によってなかったことにできるという感じ。
        - 任意のフロー <= 任意のカット容量
            - フロー = sから出ていく流量 f+(e) - sに入ってくる流量 f-(e)
            - カット = sから出ていく辺の容量 c+(e) - 0
            - c+(e) >= f+(e) かつ -0 > -f-(e)なので
            - カット >= フロー
        - 残余グラフでもう流せないということは、このときのフロー = カットの容量となっている
            - 残余グラフで流せない -> s->tへ向かう辺はもう一杯 & t->sへ向かう辺は流れていない（逆辺の容量=0)
            - sから出ていく流量 -> いくつかの辺の c(e)の和
            - sに入ってくる流量 -> 0
            - つまり、カットの容量に等しい
        -　以上から、残余グラフで流せなくなっている状態ではフローとカットは等しく、
        - それぞれ最大フローかつ最小カットとなっている
    - Dinic法
        - 残余グラフに水を流す、という作業は順番に依存しない。（増加するならなんでもいいから）というのが肝
        - 気持ちとしては、どうせ順番気にしないなら、効率的に増加パスを見つけたいよねくらいのイメージ。
        - 常にその時点での最短経路（容量は気にせずグラフ上の）を見て増加パスを探しに行く。
        - 最短経路じゃないパスに流すべきのこともあるが、ステップを続けていけばいつか最短経路に現れる。
        - 一回のステップ -> bfs + dfsとする
        - bfsでは容量>0となる辺だけを選んだ時のsからの各ノードの最短経路を覚える（このとき容量は考えずに各辺1の重みで計算)
        - 最短経路をたどってdfsを、流せなくなるまでする。このとき、実装上のiter[v]が同じ辺を二度見ないようにしてるのがポイント。
        - 
- ARC 074 F Lotus Leaves　
    - 概要
        - H*Wのマスに葉っぱが浮かんでいて、葉っぱ間の移動が可能なカエルがいて、
        スタートからゴールまでたどりつけなくするために取り除く必要のある最小の葉っぱの数
    - 解法
        - 葉っぱ間を全てエッジとしたくなるが、そうすると最小カットの結果が葉っぱの枚数と合わなくなる
        - ノードを0~H, 0~W, s, tとする
        - 0~Hは、yがy_iでxがどこかにいる、という状態。0~Wは、xがx_iでyがどこかにいる、という状態。
        - はっぱが(y_i, x_i)にあったとき、y_iとx_iを容量1の辺でつなぐ。
        そのはっぱのおかげでy_iにあるほかのはっぱとx_iにあるほかのはっぱがつながることを表現
        - こうすると、この辺を取り除くことがはっぱを取りにぞくことと等価になるので、最大フローでいける。

### 3-5-2 二部マッチング

- Hallの結婚定理
    - 二部グラフで、左がU,　右がVとすると、以下の二つの条件は必要条件条件
        - 最大マッチング = U
        - Uのすべての部分集合Aに対して、|A| <= |Γ(A)| 
            - Γ(A) -> Aと接続するVの集合の数
    - すべての男が結婚できることと、どんな男の集合を選んできてもそれと結婚できる女の数のほうが多い状態であること、は同じということ

- AOJ 2480 Blame Game
    - 概要
        - 問題を理解するのがそもそも難しかった。
        - aliceとbobがそれぞれ問題があって、alice側の問題1はbob側の問題1, 2と関連している、みたいな関係がある
        - aliceが先にbobの問題のどれかを指摘し、bobは指摘された問題と関連のあるaliceの問題を指摘する。
        - 次にaliceは一巡前に指摘した問題以外からbobの問題を指摘する。bobも同様。
        - 指摘できなくなったほうの負け。
    - 解法
        - 二部グラフで、右側から始めてエッジをたどっていく。一度通ったノードは使えない。たどれなくなったのが右側ならbobの負け。左側ならaliceの負け。
        - bob側の問題に対して、すべてペアリングを作ることができたら（最大マッチング=M)、bob側としては何を指摘されても、対応したペアリング相手の問題を指摘すれば、いつかalice側で止まる。
        - 逆にペアリングを作ることができない場合、Hallの結婚定理から、bob側の問題の部分集合で、その集合の数のほうが、その集合とつながっているaliceの問題の数より大きくなるようなものがある。
        - このとき、どうやってもbob側で止まる。
        - つまり、最大マッチング==Mならbobの勝ち、そうでないならAliceの勝ち。
      

### 3-5-3 一般マッチング

- asdf

- ARC080 F Prime Flip
    - 概要
        - 0~1e7までの数字のうちx_iが表になっている
        - 値lと素数pを選んで、l ~ l+pの場所の表裏を反転する。
        - すべてを裏にするための最小の操作回数
    - 解法        
        - 011110110　⇛ 0100010101 のように0,1が切り替わるところに1を建てるようにする 配列b
        - 値lと素数pを選んで、b_lとb_l+pの01を反転する操作だと考えることができる。
        - 1が立っている場所i,jの差|i-j|が素数だったら1つの操作で0にできる
        - |i-j|が偶数だったら、2回の操作で0にできる。
            -  ゴールドバッハ予想：全ての 3 よりも大きな偶数は2つの素数の和として表すことができる
            - p1, p2で二回にわけて反転すれば0にできる
        - |i-j|が奇数でかつ素数でなければ、上記の予想から、|i-j|が任意の素数となるようにする操作を2回でできるので、３回かかる
        - 差が素数となるのはi,jの偶奇が異なるときのみ。
        - i,jを偶奇にわけて、差が素数のときは線をつないで、二部マッチングして、残りを貪欲につなぐのが最適            
        
        
## aribon 3-6 平面・空間を扱う "計算幾何"


### 3-6-1 平面幾何

- AOJ 2276 ボ～ル
    - むずかった。

- 

## aribon 3-7 GCJ の問題に挑戦してみよう

- Numbers  
(3 + √5)^n の整数部分をもとめる  
(3 + √5)^n =  an + √5 bn  
(3 - √5)^n =  an - √5 bn  がわかる
3 - √5 < 1なので、整数部分は 2 * an - 1とわかる
anを求めるために、行列累乗。繰り返し二乗法で行ける。


## aribon 4-2 ゲームの必勝法を編み出せ！

### 4-2-1 ゲームDP

- ARC 038 B マス目と駒
    - 概要
        - マス目に障害物がある。
        - 1ターンに右、右下、下どれかに動かす
        - 動かせなくなった方の負け
    - 解法
        - 後ろから負け状態を伝播する
        - 障害物、もしくは壁の状態で回ってきたら勝ちとすると楽
            - 障害物にしか行けない状態で回ってきたら負けだから
        - 再帰が楽 
    
### 4-2-2 初期状態で勝ち負けが即決まる系

- ABC 059 D Alice&Brown
    - 概要
        - X,Yの数があり、かたっぽから2i引いて、もうかたっぽにi足す
        - 操作ができなくなったら負け
    - 解法
        - (0,1),(0,0),(1,0),(1,1)が負け 
        - 操作により、X-Yは3iずれる。
        - 実験すると、|X-Y| < 1のとき、負けっぽい
        - X-Y>1 && X-Y ≡ 1のとき X-Y=1にできる
        - X-Y>1 && X-Y ≡ 2のとき X-Y=-1にできる
        - 的な感じで, |X - Y| > 1なら、|X - Y|=-1,0,1のどれかにできる。
        - 結局初手が|X-Y|が1より大きいからそうでないかでわかる 
    
### 4-2-4 Nim


- ARC 013 C 笑いをとれるかな？
    - 概要
        - ドッキリハバネロゲーム
        - 直方体を切り出してどっちかを食べる。どっちにもハバネロがあったら負け。
    - 解法
        - 切ったときに両側にハバネロがあったら負け。
        - x,y,zの両端からそれぞれ一番近いハバネロまでの座標の数が選択肢
        - ハバネロの直前まで切れるし、1個だけ切ることもできる。
        - つまり、x,y,zの両端、6山のNimゲーム
  
  
### 4-2-6 grundy数

- ARC 038 C 茶碗と豆
    - 概要
        - 茶碗に豆がAi個
        - 茶碗に数Ciが割り当てられてて、豆は i-Ci ~ i-1 の茶碗に移動できる
        - 自分のターンで豆を一つ移動可能
        - 移動できなくなったら負け
    - 解法
        - 豆が一つしかないゲームを考えると、grundy数を簡単に定義できる
            - 一番左の茶碗が0, 遷移可能な茶碗のgrundy数の集合に含まれない最小を埋める
        - 豆がN個でも、それぞれ独立に考えられるので、grundyのxorが元のゲームのgrundy
        - 各茶碗にAiあったらそれらのxorはAiが偶数なら0、奇数ならgrundy[i]
        - 各茶碗のgrundy数の計算、普通にやると i-Ci ~ i-1でループを回す必要があり、重い
    - 高速化
        - セグ木で、idx=g[i]とするとidx=iで更新していく
        - 0-gの最小値がi-Ciより大きかったら、0-gまでの全部に遷移可能になる。
        - gの最大値を求めれば良いのでgをにぶたんで NlogNでいける


### 4-3-1 強連結成分分解 (strongly connected components)

- 概要
    - 2回のdfsで強連結成分分解ができる。
    - 一回目は、適当なところから初めて、どこにもいけなくなった頂点からstackにpushする。
        - 全頂点訪れるまでやる。
    - 二回目は、まず有効辺を全部逆にして、stackに先頭からpopして、いけるところまでいく
        - いけるところがすべて一つの強連結
    - stackに先頭から、それ以外の頂点には基本いける。逆にしたのにいけるということは先頭にいけるということ。
    - つまりお互いに行き来できる。⇛　強連結　みたいな感じ。

- TDPC R グラフ
    - 概要
        - 閉路を含む有効路を２回通って、通る頂点の数を最大化
        - 一回の操作で、同じ頂点を何度通っても良い
        - ２回目に通る時、一回目に通った頂点はカウントしない。
    - 推移閉包
        - u->v, v->wならu->wがあるような、状態？
    - 解法
        - めっちゃむずかった。
        - SCCしてDAGにするのは大前提。
        - DAGをトポソして、入次数の点に
        - そっからDAG上で2頂点管理して、    


### 4-4-1 ヒストグラム長方形最大化

- 概要
    - 各ビンに対して、その高さのまま左右それぞれどこまで広げられるかのidxを保持する。
    - stackをうまく使えば、左から、右からで２回ループすれば計算できる。
        - Lの場合、stackは、上から高い順（降順）、かつindexも大きい順（降順）になっている。
        - 今見てるビンのほうがstackの先頭より低い場合はstackからpopする。
    
- D - カーペット
    - 概要
        - ヒストグラムを長方形で埋めるための最小の長方形の数
    - 解法（自力）
        - 左右それぞれどこまで広げられるかのペアが一致しているビンは、高さが同じなので、一個で埋められる。
        - 上記のL, Rのペアの通りの数をsetで数えればOK
    - 他の解法
        - 左から見てくだけでできるらしい。 https://kimiyuki.net/writeup/algo/atcoder/kupc-2013-d/
        - 更新はちょっと変える。
        - 見てるやつより小さくなるまでstackから外す、（同じだったら外さない）
        - stackの先頭と一致していなかったら、stackにいれてその時点でcnt++

### 4-4-4 Convex Hull Trick


- 概要
    - min(a_i・x + b_i) 0<i<Nの問題
    - 直線の追加とクエリをlogNでやりたい。
    - DPの漸化式でこうなったときの処理方法
    
- 参考
    - https://sune2.hatenadiary.org/entry/20140310/1394440369
    - http://satanic0258.hatenablog.com/entry/2016/08/16/181331
        - めちゃわかりやすい
     
- 理解
    - 傾きが単調減少となるように直線を並べると、あるxでの値は、下に凸な数列になる。
        - 最小値を取り得ないやつを除いてあったら！
    - 傾きをキーにして二分探索木で直線郡をもっておく。
    
    - クエリ 
        - 下に凸な数列なので、二分探索で最小値をlogNで算出可能
            - 言われたら当たり前だけど意外と知らなかった。
            - mid, mid+1を比較してmid+1が小さければ、low=midとして狭めていく。
    - 直線の追加
        - 二分探索木でもったときに間に入れる。
        - 最小値になりえないやつを弾く。    
            - ３つの直線の交点の関係を考えて、交点が傾きの大きい順に並んでなかったら、二番目の直線は不要。
                - 参考URLがわかりやすい 
    
    - K-Anonymous Sequence
        - CHTの中でも、以下の条件を持つため簡単な部類
            - クエリが単調増加
                - 直線の傾きが大きいやつ(負の傾きが小さいやつ)が最小だとわかる。
                - また、前からどんどんいらなくなるので、前から消していけば良い。
            - 直線の係数が単調減少
                - 直線群の末尾に必ず挿入されるので、二分探索木が不要

- スペースエクスプローラー
    - http://drken1215.hatenablog.com/entry/2018/09/18/014400                    