
## 基本

### 整数系
-  フェルマーの小定理
    - $a^p$ ≡ a (mod p)
    - $a^{p-1}$ ≡ 1 (mod p)

- mを法とする場合での除算
    - A ÷ B = C で、それぞれmod をとってa, b, cだとすると、
    - a * (bの逆元) ≡ c
    - 逆元は b-1 = b**(p-2)で与えられる

### 実装テクニック
- 番兵による線形探索
  - 配列のおわりに答えをおいて、while文でiをincrementすること探索中の比較を1回で住むように

### セグメント木
- 木に関するテクニック集  
https://topcoder.g.hatena.ne.jp/iwiwi/20111205/1323099376

- 理解  
要素とそれをマージする演算がモノイドなら適用可能  
モノイド->演算が結合律を持ち、単位元が存在する
(f(f(a・b)・c) = f(a・f(b・c))であればよく、f(a・e)=aとなるeがいればいい)  
https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html  
http://beet-aizu.hatenablog.com/entry/2019/03/12/171221
 
- 遅延セグ木  
作用素の適用が可換なら伝播させる必要はホントはない。
ex. [a, b) をxにする、は可換でないので伝播させないとだめ。

### グラフ

- LCA（最小共通祖先）
    - 木の２つの頂点間で共通する親頂点のなかで最も低いもの（根から遠いもの）
    - 最初に枝分かれしたところ
- オイラーツアー
    - 根から木をdfsしたときの訪れる順に、辺もしくは頂点の重みを配列にいれる（行きを+、帰りを-)
    - +e1, +e2, -e2, +e3, -e3, -e1
    - ある頂点が最初に現れたidxまでの累積和を取ると、根からその頂点までの辺（頂点）の重みの和になっている。
    
---------- 

## Atcoder Beginner Contest

### abc001
- python3の四捨五入
    - round関数はくそ (切り捨て誤差が小さくなるように偶数になってしまう）
        - round(2.5) -> 2
    - 小数点がずれて怖いときは、評価する方を掛け算してあげる
    - 1123 -> 1120 にしたいとき t -= t % 5
- いもす法
    - 立ち上がりに1、立ち下がりに-1を入れておいて、最後累積和を取ることで >0 なら雨、==0なら晴れになる

### abc002
- 最大クリーク問題
    1. 所詮N = 12だから2**12で回す
    2. クリーク数決めてcombinationであるかないか、というのを友達の数でmaxとって二分探索
    3. for i in range(N) 友達増やしてみて現在の友達全員と友達かどうかを判定
    
### abc003
- 包除原理
    - 結構めんどかった. 
    - たてよこ、たてよこの組み合わせ6通り、 たてよこ３つ選んだとき、たてよこ全部
    - (1, 2, 3, 4) - (0, 1, 3, 6) + (0, 0, 1, 4) + (0, 0, 0, 2)
    - それぞれありうるかどうかの条件も必要

### abc004
- マーブル
    - 時間かかった。できるだけ関数は再利用していこう

### abc005
- imos法
    - N+1*N+1の配列を作っておけばindexが-1の例外処理がいらなくなる

### abc006
- LIS

### abc007
- 桁DP

### abc008
- コイン裏表の枚数の期待値
    - 約数を数え上げ、左側に約数が奇数枚くる確率を計算、確率がそのまま期待値になる。賢い
- 金塊ゲーム
    - メモ化再帰サイコ〜

### abc009
- 漸化式は行列の累乗を利用することでO(logn)で解ける！
- AND、XORを足し算掛け算のように扱う (半環)

### abc010
- ある点から他の点に何処か寄り道してから向かうという問題で、移動距離Lが決まっている場合楕円内にある点にならいける
- Dめちゃむずかった
marked girlのそれぞれの後ろにもう一つノードを設け、ログインできなくする工作をそのノードを切ると見なしそれぞれの工作をまとめる
最小カット最大フロー定理
ford-fulkersonのアルゴリズム
    - 適当に流す。流した流量をdとすると、流した方向のエッジに重みdを足し、逆方向を向くエッジ(capacity 0)に-dを足す (残余ネットワーク)
    - 流せなくなるまで続ける

### abc011
- 貪欲法
- combinationはパスカルの三角形使うと良いらしい

### abc012
- ワーシャルフロイドはpython通らない

### abc013
- 満腹な高橋くん(下からDP、順番関係ないからXによってのみほかが決まる)
- 巡回置換 
巡回の操作も累乗の足し算作戦
リストの削除普通にやると死ぬほど遅いので二分探索

### abc014
- 最小共通祖先 (LCA)
- pythonきびしいな〜

### abc015
- ナップザック亜種
後ろからループ回すことで品物数のループをする際メモリを使いまわせる

### abc016
- D 一刀両断
    - 交点問題
    - 直線を挟んで逆側にあるか -> 片側から見て外積の積が負
    - 線分内に交点があるか、両端からみて外積の積が負

### abc017
- 宝石と魔王ゲーム
    - imos法
- サプリメント
    - dp & imos法　難しかった
    - dp(i) にはi番目のサプリを食べおわったときの組み合わせ

### abc018
- ひし形カウント 難しかった ある方向に関して両側開いてるマス数を保存しておく
- 半分全列挙

### abc019
- 木の直径
    - ある点（なんでも良い）から一番遠い点xからみて一番遠い点yとすると、x-yの距離が直径

### abc020
- ダイクストラ & 二分探索
- 最大公倍数の列挙 むずかった

### abc021
- DAGの数え上げ ダイクストラで最短経路出してからメモ化再帰
    - queue突っ込んだ順に取り出す方式なら、初めて通ったノードは確実に最短経路 
    - 二回目以降は、最短経路と同じなら足す
- nHr

### abc022
- 最短閉路
    - 閉路はスタートのノードを除けば経路になる 
    - ワーシャルフロイドで全点対最短距離を求めておいて、スタートに接続するノードを２つ選ぶ 
    - $O(N^3) + O(N^2)$ \\
    - ダイクストラで最短経路木求めながらスタートから生える枝にIDをつける
    - 最短閉路は
    - ある枝の途中からスタートに帰ってくる場
    - ある枝から他の枝に移動して返ってくる場合のどれか
    - $O(N^2)$
- 天体の膨張
    - 平行移動、回転によって影響を受けない距離の比を考える
    - 全天体の距離の総和、最近点の長さ、最遠点の長さ、重心からの最近点、最遠点の距離

### abc023
- 収集王
    - 縦横の和がある数字に まとめてから
- 射撃王
    - 最小化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

### abc024
- 民族大移動
    - 貪欲法
- フェルマーの小定理

### abc025
- ゲーム木探索
- 25個の整数
    - 難しかった

### abc026
- 数値計算の二分探索

### abc027
- ロボット
    - ある時刻において右に動いた場合の将来的な収支は計算できる
    - 高い順に並べて低いところで左に行けばいい

### abc028
- 特になし

### abc029
- 特になし

### abc030
- 特になし

### abc031
- 語呂合わせ
    - 文字数先に決めてしまって確認

### abc032
- ある積以下の最長部分列
    1. 1は積に影響しないのでまとめる, 10**9は実は掛け算だとO(logN)だからそんな大したことない 
    2. 尺取法 O(N)
    3. logとると和になるので、累積和が使える。長さｘを二分探索 O(NlogN) (誤差めんどくさそう）
    4. 現在の最大の長さ以下の探索はしなくてよいので、尺取法において一つ減らすだけで良い
- ナップサック
    - 価値でDP
    - n少ないがW,Vに上限がない場合 ２つに分けて全組み合わせ列挙 -> いらないのはぶいてそれぞれいい感じに突き合わせる（二分探索）

### abc033
- abc簡単
- 鈍角、直角三角形


### abc034
- B - ペア
    - 100 -> 101, 101 -> 100 n^1
    - 99 -> 100, 100 -> 99 (n-1)^1+1
- D 食塩水
    - 最大化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

### abc035
- 有向グラフにおける行きと帰りの最短距離 -> 帰りは矢印を逆にしてダイクストラ

### abc036
- treeDP
    - いい問題だった。自分が白の組み合わせと、どちらでもいい組み合わせの漸化式

### abc037
- pythonおせえ〜

### abc038
- BIT, LIS
    - (i&-i) で rightmost set bit だけ取り出せる

### abc039
- 特になし

### abc040
- union-find木

### abc041
- bitDP, 2**nのDP

### abc042
- 行けない場所があるときのグリッドの経路組み合わせ

### abc043
- アンバランス

### abc044
- 選んだ合計の平均がA -> それぞれの要素を x - A とすると合計が0になればいい

### abc045
- D - すぬけ君の塗り絵 / Snuke's Coloring
    - 概要
        - H*WのマスのN個を黒く塗られている
        - 全3x3の領域でk個塗られているものが何個あるかをk=0~9まで数える
    - 解法
        - H,Wが10^9なので普通には無理。
        - 座標圧縮したくなってしまったけど、x,yが単調増加でずっとあると、圧縮後もそれぞれ10^5あるから無理だった。
        - 関係あるのは黒く塗られているところなのでその周辺を見ればいい。
        - 近くに黒丸が２つあるとダブルカウントしかねないので覚えておく。

### abc046
- C - AtCoDeerくんと選挙速報
    - ある値bを超えるようなaの倍数を求めるだけ
    - max(((t + T[i] - 1) / T[i], (a + A[i] - 1) / A[i]))
    
- D - AtCoDeerくんと変なじゃんけん
    - グーを出した回数しかパーを出せないじゃんけんの戦法
    - 相手も同じ戦法になってることに気づくのに時間かかった。
    - 相手が無駄にグーを出してる数だけが重要。
    
- E - AtCoDeerくんと立方体づくり
    - 概要
        - 4隅に色がついている正方形がたくさん
        - 正方形を6枚えらんで立方体をつくる。接する頂点の色は同じである必要。
        - 立方体が何通りあるか
        - 回して一致するなら同じ立方体とする
    - 解法
        - 上面を一番小さい数にして向きも固定すれば、まわして一致のダブルカウントを防げる
        - 下面と向きを固定すると頂点の色が確定する
        - 横の面の組み合わせを考える。
        - 上面と下面と同じやつを使ったらだめで、横には一種類しか使ったらだめ
        - 色の組み合わせをmapでもって、使った正方形を回した4組をmapから消す。
        - 4色をmapのキーにするときpairでやっちゃったけど、ハッシュ化したほうが良い 

### abc047

- B	すぬけ君の塗り絵 2 イージー / Snuke's Coloring 2 (ABC Edit)
    - 領域狭めてくやつ
    - 超愚直に塗ったが、白の領域は内部の長方形なのでl,r,u,dを覚えておけばよかった。
    	
- C	一次元リバーシ / 1D Reversi	
    - 文字列の変化点をかぞえるやつ
    
- D	高橋君と見えざる手 / An Invisible Hand
    - 問題設定ややこしい。
    - 結局i,jのペアでaj-aiが最大となるやつの組み合わせの数。
    - なぜか二分探索木で最大を求めてmx-aiで求めたが、最小値を覚えながらai-minでよかった。

### abc049
- C	白昼夢 / Daydream
    - dream, dreamerで作られた文字列か判定
    - 前から見ると分岐が生じるので後ろから見る
    - 後ろのidxを持ってsubstrしたが、全部ひっくり返して前から見る作戦もある。
- D	連結 / Connectivity
    - 線路による連結成分と、道路による連結成分がそれぞれある。
    - どちらでも連結していることの判定
    - UnionFindをふたつもって、rootのidxのペアが一致していれば連結していると言える。
    - ペアをmapでもてば、どちらでも連結している都市の数がわかる。

### abc051
- C	Back and Forth
    - 点から点へ向かう4通りの矢印書いていくだけ。
    - 正負の処理の共通化を少しきれいに書けた。
    
- D	Candidates of No Shortest Paths
    - 最短経路としてつかわれない辺の数
    - ワーシャルフロイドして、全点間最短距離を出しておく。
    - dist[i][j] < edge[i][j]だったらその辺は使うことはない。
    - 逆にそうでなければ、少なくともそのi, jの最短経路に使うのでOK。(等号の場合も同じ)
    - つまりこれだけ。解説より簡単そう。

### abc052
- C - Factors of Factorial
    - N!の約数の総数

- D - Walk and Teleport
    - 歩いて移動するか、テレポートするか
    - 結局隣に歩くかテレポートしかないので、貪欲

### abc056

- C	Go Home
    - 問題
        - 時刻iに、x-i, x, x+iに移動できる
        - Xにたどり着く最小の時刻
    - 解法
        - n*(n+1)/2 >= xを満たす最小のnを考える
        - どこかの時刻tで戻った場合は、n*(n+1)/2 - 2*t, stopなら n*(n+1)/2 - t
        - という感じで調整ができる。
        - n*(n+1)/2 - x < n　なので、この調整でどうにかなるので n が答え
    
- D	No Need
    - 問題
        - 総和がKになる部分集合を良い集合という
        - カードiを含むよい集合のうち、iを除くと総和がK未満になってしまうものがない ⇛　カードiは不要
        - 不要なカードの枚数を求める
    - 解法
        - カードiを使わずに取りうる和は、dpでO(NK)で求まる
        - K-a[i] ~ Kの和のうちどれかを作れるなら、カードiがあるおかげで良い集合になるような部分集合があるということ
        - どうやったら戻すDPができるかなーと考え、よくわからず、
        - 明らかに、大きいカードのほうが必要なので単調性があるので、にぶたんで上記を毎回やった。
        - O (NKlogN)
    - かっこいい解法
        - 0 ~ iまでを使った時点での取りうる和のdp配列と、
        - N ~ iまでを使った 時点での取りうる和のdp配列　をもっておけば、
        - 各iを使わなかった場合の取りうる和をO(K)で求められる。
            - やや語弊があり、0-i, i-Nの和で K-A[i]~Kのものがあるかどうかがわかる
            - この場合O(NK)
        


### abc058

- D - 井井井 / ###
    - TODO
    - やらかし
        - 自分のmodintライブラリ、long longとの+=がおーばーろーどされておらず、
        intの +=が使用されていた？のかうまく通らなかった。。

    - 幅に変えたが、座標のまま扱ったほうが簡単そう。TODO

### abc059
- C. Sequence
    - ai+1までの和の符号がaiまでの和の符号と異なるようにする。
    - 1番目を正にするか、負にするかを２通り試す。
    - 決めたら、和をとって前回値と同じだったら+1か-1まで変更する。
    - iの値の変更とi+1の値の変更が結局同じなので、貪欲にいける。
    
- D Alice&Brown
    - 概要
        - X,Yの数があり、かたっぽから2i引いて、もうかたっぽにi足す
        - 操作ができなくなったら負け
    - 解法
        - (0,1),(0,0),(1,0),(1,1)が負け 
        - 操作により、X-Yは3iずれる。
        - 実験すると、|X-Y| < 1のとき、負けっぽい
        - X-Y>1 && X-Y ≡ 1のとき X-Y=1にできる
        - X-Y>1 && X-Y ≡ 2のとき X-Y=-1にできる
        - 的な感じで, |X - Y| > 1なら、|X - Y|=-1,0,1のどれかにできる。
        - 結局初手が|X-Y|が1より大きいからそうでないかでわかる 

### abc070

- D - Transit        
### abc071

- D - Coloring Dominoes
    - 2 * Nマスに、敷き詰められたタイルの色の塗り分け方
    - タイルは2x1, 1x2しかない。
    - タテ->タテ: 2、タテ->ヨコ: 2, ヨコ->タテ: 1, ヨコ->ヨコ: 3 通り濡れる
    - 書くだけ。
    

### abc100

- C	*3 or /2
    - 2で割れる回数を求めるだけ。
    - 貪欲に2で割っていって求めたが、二分探索で割れなくなる数を求めるとさらに高速化できる。
    
- D	Patisserie ABC
    - N個のケーキがあり、x, y, zの3つの指標がある。(それぞれ負もある)
    - M個食べて、x,y,zの合計の絶対値の最大値
    - 普通にやるとむずいので、x,y,zそれぞれについて、正の方向で最大化するのか、負の方向で最大するのか、8通り全部調べる。

### abc102

- C	Linear Approximation
    - |ai-b|が最小となるbを求める
    - bがaiのmedianのとき最小なので、ソートして終わり
    
- D	Equal Cut
    - 数列を4つに分割して、それぞれの和P,Q,R,Sの最大値と最小値の差の最小
    - P,Qの差の最小化だけを考えるなら、P+Q/2に近いところで切るのが最適。
        - これは累積和でにぶたんすればlogN
    - つまり、Q,Rをどこで切るかを全探索して、P,QとR,Sの切れ目は貪欲で決まる
    - P+Q/2に近いところできる実装がめんどかった。**まだいい感じの実装わかってない**


### abc103

- C	Modulo Summation
    - f(m) = m % a_1 + ... + m % a_n
    - f(m)の最大値
    - m = a_1 x ... a_n - 1とすると、それぞれの項でa_i-1にできるので最大。
    
- D	Islands War
    - 島aと島b間が行き来できないようにはしを落とす。
    - 区間スケジューリング
    - bでソートして、すでにa以降で橋を落としていればそのまま、そうでなければ落とす貪欲
    



### abc104

- C all green
    - 間違えた。。。
    - にぶたんしたくなるが、全完するセットをbit全探索
        - にぶたんで、全完した場合の一問あたりの得点と全完しない場合の得点を同じリストにいれて貪欲した
        - Aが全完可能の場合で、その次に選ぶ全完しない問題の得点が低い場合がある
        - その場合、Bを全完してAをちょっと解くほうがいい場合がある、ので貪欲はだめ。
- D we love abc
    - 概要
        - ?ABCを含む文字列からS_i,S_j,S_kがABCになるような組み合わせ
        - ?は全通り考える。
    - 解法
        - あるiまでに作れるAB(?を考慮する)の数を覚えておく
        - ?が出た場合、iまでに作れるABを3倍して、今までのAと?で作る、今までの?と?で作れる場合
        - C, ?が出たらans += AB, ?の場合は今までに作れるABCを三倍する必要もある    

### abc105

- B Cakes and Donuts
    - 4A + 7B = NとなるようなA,Bが存在するかどうか。
    - 解法自体は全探索するだけだが、
    - N>=21なら、N,N-7,N-14,N-21の中に4の倍数が存在するので、必ず存在する。面白い。
    
- C Base -2 Number
    - 与えられた数字を-2進数表示。
    - 結構時間かかった。。
    - また1 << iでlong longにしてなくてオーバーフローやってしまった。。
    - 自力解法
        - i番目のbitが1だったときに取りうる値の範囲を求めて計算した。
    - 想定解法
        - 2で割ったあまりに寄与するのは結局 0bit目のみ。
        - 同様に、4で割ったあまりに寄与するのは0,1bit目のみ。
        - つまり順々に決まる。
        - それはそう。。
        
- D Candy Distribution
    - ABC146E Rem of sumの簡単版
    - 問題
        - Al + .. + ArがMの倍数となるようなl,rの組み合わせ
    - 解法
        - Al + .. + Ar = S_r - S_l ≡ 0 (mod M)になっていればよい。
        - つまり、累積和をとったときに、あまりが一致していれば良い。
        - 左から累積和を計算しながら、過去に現れたあまりの数をカウントアップしていけばよい。



### abc106

- C	To Infinity
    - 5000兆日目のやつ。K番目までに1以外が現れたらそれ。現れなかったら1
    
- D	AtCoder Express 2
    - 概要
        - L,Rの区間を走る電車がある
        - 区間p,qに 走行区間が完全に含まれる電車の数はいくつか。
    - 解法
        - 結構むずかしいとおもうけど。。
        - 各電車のL, Rを二次元座標にマッピングする。
        - するとp, qに含まれる⇛二次元座標で長方形に含まれる電車の数。
        - 二次元累積和でとける。

### abc107

- B	Grid Compression
    - "#"がないところを消すやつ
    - "#"の数を数えちゃったけど、"#"が出たらtrueにして、あとでfalseを除けばよかった。
    
- C	Candles
    - ろうそくをK個灯すための最小移動距離。
    - 行って戻る系。
    - ばぐらせた。。
        - 負⇛正に変わるところのidxを計算してたが、正がない場合はidx=N。N-1ではない！！ 
    - 最小値系は、無駄なところを計算して問題ない。
        - （行って戻る必要があるのは明らかに連続するK個の領域の内部にスタートがある場合だが、そうでない場合をがんばって計算しないようにする必要はない。)
        -     REP(i, n-k+1) {
                  ans = min(ans, abs(x[i]) + abs(x[i+k-1] - x[i]));
                  ans = min(ans, abs(x[i+k-1]) + abs(x[i+k-1] - x[i]));
              }
        - こんなんでよい。        
- D	Median of Medians
    - 例の
    - 中央値 ⇛ x以上の値がceil(M/2)個あるようなxのなかで最大値
    - にぶたん && 累積和 && BITによる転倒数カウント



### abc108
C - Triangular Relationship
    - a+b, b+c, c+aがKの倍数となるようなa,b,cの組み合わせ
    - 2*a ≡ 0 (mod K)と出てくるので、Kの遇機で分岐
    - Kが奇数なら、a,b,cが全てKの倍数であることが必要十分
    - Kが偶数なら、a,b,cが全てKの倍数か、全てKでわって(K/2)あまること
    
D - All Your Paths are Different Lengths
    - パスの通り方で0~L-1までの全ての距離を作れるようなグラフの構築
    - 2べきと0の辺をつなげていくと、0~2^r-1までは作れる。
    - 重みは自由に設定できるので、残りは途中からNまで重みをつければ、X~X+2^t-1が作れるので、
    そんな漢字で適当につなげる。


### abc109
- D - Make Them Even 
    - 各マスにコインがあって、コインが偶数になるようにするやつ
    - 奇数だったら右に移動、を貪欲にやっていって良い。最後に最終列を縦に掃除。
    - 無駄に時間かかった。

### abc110
- D	Factorization
    - a1 x a2 x ... x an = M
    - となるようなa1...anの数列の通り。（一個でも違えば良い）
    - Mを素因数分解したとき、素因数ごとに独立に考えて良い。
    - p^dとすると、d個のpをn個のグループ割り振る重複組合せ通り。

### abc112
- D	Partition
    - a1+..+an = Mを満たすa1~anの最大公約数の最大値
    - Mの約数dで、M/dがnより大きければ作れるので、約数を大きい方から見るだけ

### abc113

- D - Number of Amidakuji
    - 概要
        - 1からはじめて、K番目に到達するようなあみだくじの数。
        - 棒を連続でつけたらだめ
    - 解法
        - dp[i][k] i番目の高さで、k番目にいる数
        - 次の遷移は、連続して棒をつけない組み合わせ。
        - 全部列挙すればいい。 1 << w個
        - もしくは、dp[j] = dp[j-1] + dp[j-2]        

### abc114
- C. 755
    - 桁DPっぽくみえるが、ありうる数字を列挙して、N以下なら足していく方式。
    - わからなかった。。。
    
- D. 756
    - これは簡単だった。
    - 約数が75個あるやつを数える。
    - 約数の数は、素因数分解したときの各素数の肩の数字+1の積なので、やるだけ。  


### abc116
- D. Various Sushi
    - 概要
        - 寿司iに、美味しさと種類が割り当てられてる
        - K個選んで、美味しさの合計 + 種類数^2　の最大値
    - 解法
        - f(x) = 種類xこ選んだときの美味しさの最大値
        - 貪欲に大きい方から選んだときの種類数xkの f(xk)は自明
        - f(xk+1) = f(xk) + A - B
        - A = 貪欲に選んだときに選ばなかった種類の寿司の最大値を足して、
        - B = 今選んでるうち、種類数が減らない（2個以上あるやつ）なかから最小値を引く
        - これ続けてf(x)埋めて f(x) + x*xの最大値             
   


### abc117
- D - XXOR
    - 概要
        - A1 ~ Anが与えられる
        - X = [0 ~ K]で、
        - f(x) = (X xor A1) + ... + (X xor An)の最大値
    - 解法
        - bitごとにみたときに、明らかに A1~Anで、0,1の多い方にしたほうがよい。
        - Kより大きくならないように桁DPするか、
        - どこのbitを x < kにするかの全探索

### abc118

- D - Match Matching 自力
    - 概要
        - ある数を表すマッチを構成するには、それぞれ決められた本数が必要
        - 作れる数と、マッチ本数が与えられる。
        - 全てのマッチをちょうど使い切る条件で、マッチで作る数字の最大値
    - 解法1
        - 明らかに、桁数が大きいほうが数が大きいので、使うマッチ本数が一番少ない数をいっぱい作るのが良い。
        - ちょうど作らないといけないので、最後調整が必要
        - 一番少ない本数をk、一番少ないやつで埋めたときのあまりをrとすると、
        - r, r+k, r+2k, をちょうど作れるやつのなかで一番おおきくなるやつを作る。
        - ちょうど作れるやつはDPで作っとく。
        - みすったとこ
            - ちょうど作れるやつを見つけたらbreakしてたけどだめだった。
            - 3=5, 8=7, 9=6で 8833と9999は 8833のほうが3をいっぱい作っているが、
            - 10+14=24で使う本数が同じかつ9999のほうが大きいので、breakせずもう少し見る必要がある

### abc119

- C - Synthetic Kadomatsu
    - 概要
        - 竹を何本か選び、A,B,Cの長さの三本にする
        - +1, -1, 合体の魔法を使える
        - 最小のMP
    - 解法
        - 全ての竹をA, B, C, 使わないのどれかに割り振ったら、その後は貪欲
        - 4^Nを全探索
    
- D - Lazy Faith
    - 概要
        - 神社と寺が数直線上にある
        - ある点が与えられて、神社と寺に訪れる最小移動距離
    - 解法   
        - 左側、右側の神社と寺をにぶたんで見つける
        - 右右、右行って左左、など色々試して最小見つける
### abc120

- D - Decayed Bridges
    - 概要
        - 無向グラフの辺を順に削除する
        - ある時点であるノートとノードが行き来できるか
    - 解法
        - 削除は難しいので、逆に構築していき、UnionFindで管理

### abc121

- D XOR World
    - 概要
        - f(A,B) を A,A+1,...,B の排他的論理和としたとき、f(A,B) を求めてください。
    - 解法
        - a xor b = cとすると b = a xor cなので
        - f(B) xor f(A-1)で良い。
        - 想定解
            - n xor n+1 = 1　(nは偶数)を使うと、
            - 1 ~ 6のxorは、1 xor 1 xor 1 xor 6になる
        - 自力解
            - bitごとにそのbitが立つのが何個あるか頑張って計算 
        
### abc122

- C - GeT AC
    - Sの[l, r)の'AC'の数。累積和のもちかた、ちょっと考える必要
    
- D - We Like AGC
    - 以下の長さNの文字列の数
        - AGCTしか含まない。
        - AGCを部分文字列として含まない。
        - 隣り合う文字をswapしても上記を満たさないといけない
    - dp[i][s1][s2][s3] : i番目まで見て, 先頭3文字が s1s2s3の数
    - 丁寧にAGCを含まない場合を処理していくだけ。

### abc123
- D - Cake 123
    - 概要
        - 3種類のケーキがあり、それぞれX,Y,Z個ある
        - X*Y*Zの組み合わせのうち大きいほうからK個列挙
        - X,Y,Z~1000, K~3000
    - 解法
        - X*Y*Zは当然間に合わない。
        - X*Yの組み合わせのうち、最終的に使われるのは、大きいほうからK個のみ。
        - つまりX*Yの上位K個とZでまた列挙して上位K個なので, O(K * Z)
        
       
     
### abc124
- D - Handstand
    - 概要
        - 0 or 1からなる文字列
        - [l,r)の0,1をすべてひっくり返すをK回行える、連続して1が続く長さを最大化
    - 解法
        - 010011100011
        - 連続する0をひっくり返す操作を、K箇所続けて行うのが一番良さそうなのがわかる
        - 連続する0, 1の数の配列のK個の連続部分和をN-K通り試す。
    - 工夫
        - 1100110011のように1が外側にあるとしたほうが扱いやすいので、
        端が0でも、1が0個あるという風にした。
   
### abc125
- C - GCD on Blackboard
    - 概要
        - A1 ~ An (Aは自然数)
        - どれか1つを自由に書き換えたあとのすべて数の最大公約数の最大値
    - 解法
        - 肝は gcd(A,B,C) = gcd(gcd(A,B), C) であること
        - 想定解
            - L[i], R[i]をずらしていく。L[i]は左からi番目までの最大公約数で、R[i]は右から。
            - 書き換える、というのをgcdの計算に入れない、という発想
        - 自分解
            - セグ木で、ノードのマージをgcdにした。
            - gcd(a,0) = aなので、単位元が0になって割ときれいに解けた。
            - 各Nに対して、0にセット->根クエリ->もとの値セットで最大値探索
            
- D - Flipping Signs
    - 概要
        - A1 ~ An (Ai は負もある)
        - 連続する2つに-1をかける操作を好きなだけして、和を最大化する
    - 解法
        - -10, 5, -4
        - 負の数が偶数なら、結局全部正にできて、奇数なら1個だけ負になるようにできる
        - 奇数のとき sum(A) - 2 * min(abs(A))でOK

### abc126
- D - Even Relation
    - 概要
        - 重み付き木を白黒に塗り分けて、
        - 同じ色の距離が偶数になるように
    - 解法
        - uとvの距離は、du + dv - 2 * d_lca
        - ３項は偶数なので、du + dvが偶数 -> 適当に根決めて距離が偶数、奇数で塗り分ければ良い。        

- E - 1 or 2
    - 概要
        - A1 ~ An (A=0,1)
        - Xq, Yq番目の和がわかる、という情報がQ個
        - 何枚のカードをめくればすべての情報がわかるか
    - 解法
        - 1,2の和がわかって、2,3の和がわかってれば、1,2,3のどれかがわかれば他がわかる
        - つまりUnionFindで結合していって、素集合の数が答え

- F - XOR Matching
    - 概要
        - 0 ~ 2^Mの数を2こずつ含む数列で、
        - 同じ値の間に含まれる数のxorがすべてKとなるような数列の構築
        - ai == ajのとき、 ai xor ai+1 xor ... xor aj = K
    - 解法
        - a xor a = 0
        - a,b,c,d,e,K,e,d,c,b,a,K
        - ってやれば、a-a,b-b,...,e-eについて間のxorは打ち消しまくってKが残る
        - K~Kの間はa,b,c,d,e,K,Kのxorだが、0~2^M-1のすべてのxor(=X)とKのxor
        - Xは各bit見たときちょうど0と1が2^(M-1)回出るはずなので、必ず0
        - つまり、全ての数に対して間のxorがKになる
        
### abc127

- E - Cell Distance
    - 概要
        - NxMのマス目にK箇所にコマをおいたときの、全てのコマ間距離の総和の、全ての置き方に対する和
    - 解法
        - ある1マスxに関連する距離の和をまず考える
        - xとaにコマが置かれるのは、その2マスを除いてK-2コマ分選ぶので、N*M-2 C k-2
        - これはxから見て、全てのマスa=1~NMに対して成り立つので、
        - N*M-2 C k-2 * （xから全マスへのマンハッタン距離の和)
        - 実は、全てのマスに対してこれは成り立つので、
        - N*M-2 C k-2 * Σ_x_N（xから全マスへのマンハッタン距離の和) / 2
        - が答え
        
- F - Absolute Minima
    - aのmedianがmin_xとなる。
    - 最小値を取り出すpriority_queueと最大値を取り出すpriority_queueをごちゃごちゃする。

### abc128
- E - Roadwork
    - 概要
        - N個工事があり、Si ~ Ti の時刻, 座標Xiを通行止めにする
        - M人が時刻D[i]から時速1で移動し、通行止めにあたったら止まる。止まる距離を答える
    - 解法
        - S-X, T-Xにしたほうが扱いやすい
        - Sでソートすると、D[i]を考えるときに、すでに始まってる工事を取り出せる
        - すでに始まってる工事を、xが近い順に取り出せるpriority_queueにつっこんでおく。
        - すでに始まってる工事の中で、一番近い工事を取り出し、まだ終わってなければそこで終了。
        もうTよりD[i]が大きく、終わっていたら、popして次に近い工事を取り出す。
        
- F - Frog Jump
    - 概要
        - A進む->B戻る->A進む->B戻る　を繰り返して、蓮にある点数を取得、すでに訪れたところに行ってはいけない。
        - 得点の最大化
    - 解法
        - A, A-B, 2A-B, 2A-2B -> A-BをCとすると、
        - A, C, A+C, 2C, A+2C, 3C, ... , A+kC　となりキレイ。
        - A + kC = N − 1 なので、Cとkで全探索できる。
        - さらに、k, Cのときの得点をf(k, C)とすると、
        - f(k+1, C) = f(k, C) + S_(N-1-kC) + S_kC なので, f(k, C)の計算はO(1)
        - 調和級数 Σ_k n/k ~ O(nlogn)なので、k, Cの全探索は O(nlogn)なので間に合う
              
### abc129
- E - Sum Equals Xor
    - 概要
        - a + b <= L
        - a + b = a xor b
        - となるa,bの組み合わせの数
    - 解法
        - i番目のbitで、Lより真に小さいか、否かを持ちながら上位bitから桁dp
        - ab=00, 01, 10が選べる。

- F  Takahashi's Basics in Education and Learning
    - 数列の遷移を行列の掛け算で表現することで、数列のN番目の要素をlogNで求める

### abc130
- E - Common Subsequences
    - レーベンシュタイン距離的な感じ。
    
- F - Minimum Bounding Box
    - xmaxに着目
    - xmaxになりうる点の候補は、L, R, U, Dの方向を向いているうち一番xが大きいもの (xmax_candidate)
    - t秒立った時点で、 xmax = max(L_xmax - t, R_xmax + t, U_xmax, D_xmax)
    - xmaxは下に凸の折れ線となることがわかる ＼_／ こんな感じ
    - xmax, xmin, ymax, yminそれぞれ同じこと。
    - ここで、面積が最小となるのは、xmax, xmin, ymax, yminの極小点（折れ線の頂点）のどれかだとわかる。
    - この極小点はせいぜい12個しかないため、全部試せばOk

### abc131
- E - Friendship
    - 概要
        - N頂点グラフで、距離が2となるような頂点i,jの組がちょうどK個になるものの構築
    - 解法   
        - うにをつくると、N-1C2がすべて距離2になる。
        - うにの各頂点間を１本つなぐと、距離2の組み合わせが1つ減る。
        - N-1C2 - K 本つなげばOK
        
- F - Must Be Rectangular!
    - 頂点間でx, yのどちらかが一致していたら辺が張られるようなグラフを考える。
    - 求める答えは、このグラフ上での各連結成分内の (xの値の種類 * yの値の種類 - 頂点の数)の和

### abc132
- D - Blue and Red Balls
    - 赤、青のボールの組み合わせ

- E - Hopscotch Addict
    - けんけんぱでダイクストラ
    - 各頂点に0,1,2の状態をもたせ、接続している頂点で自分の状態+1に遷移できるダイクストラ 
    
- F - Small Products
    - 数列の末尾がaだったとき、次の要素の取りうる範囲は 1 ~ floor(n/a)
    - 列挙してみると、n/b+1 ~ n/b では、次の要素の取りうる範囲が1 ~ bで変化しない
    - bの取りうる値は、2*√n 通り 。
    - いい感じにまとめてあげればO(√n・K)で解ける
    
### abc133
- D - Rain Flows into Dams
    - 数式建てると一周して方程式になるので、一意に決まる

- E - Virus Tree 2
    - 考えるだけっちゃ考えるだけ
    
- F - Colorful Tree   
    - 概要
        - 	辺の色と重みがついていて、根からある頂点までに現れる、特定の色の辺の数、重みの和を計算する必要がある
        - 	色と頂点を配列で持つと、空間計算量が O(N^2)になる。
    - 解法1
        - 	オイラーツアーを色ごとにリストで管理して空間計算量をO(N)に落とす。
        - 	元のオイラーツアーでの出現箇所のidxと重みのタプルを保持することで、根から頂点までの各色の重みを二分探索で計算 O(QlogN)
    - 解法2
        - クエリを先読みして、DFSしながら訪問中に頂点分の各色の重みを保持し、解答に必要な部分の計算をその時点で行う O(N+Q)

### ABC134

- D - Preparing boxes
    - 概要
        - a1 ~ aNが与えられる
        - 1~Nの任意の整数iの倍数が書かれた箱に入っているボールの個数の和を 2 で割った余りが ai である
        - これを満たすb1~N  bi=(0 or 1)があるかどうか
    - 解法
        - 後ろから貪欲に0か1を決めていく。

- E - Sequence Decomposing
    - 概要
        - AiとAjが同じ色で塗られているならAi < Aj
        - を満たすように色を塗るときの最小の色の数
    - 解法
        - Longest Decreasing Sequenceを解くだけ。
        - 負にしてLIS貼れば終わり。
                       
- F - Permutation Oddness
    - 箱根駅伝DP と呼ばれるもの
    - ペアリングによって値が決まるとき、今までにペアリングを保留している要素の数、を管理することできれいにDPが決まる。


### ABC137

- D: Summer Vacation
    - M日後の報酬が最大となるA日後にB円もらえるバイトのうけかた 
    - なんか結構時間くった
    - 後ろから受けられるバイトの候補を増やしながら候補の中で最大報酬をうける
    - 候補を増やすpriority queueと、候補の最大のためのpriority queue
    
- E - Coins Respawn
    - 1分かかる辺を、辺のコインを拾いながら目的地に向かい、T分 * P枚のペナルティを払ってゲーム終了
    - コインの枚数をc - pとしてベルマンフォード
    - 目的に向かわない負閉路をNGにしてしまってみすってた
    - あと勝手に同じu, vの辺のコインを足してしまってたけど、別の辺がある扱いだった。。
    
- F - Polynomial Construction
    - f(x) = Σ_0~p-1 b_i * x^i　として、
    - f(j) == a_j (j=0~p-1)を満たすb_iを求める。a_j = [0, 1]
    - 想定解はかなりきつい
        - フェルマーの小定理からa^p-1≡1 より、
        - g(x, j) = 1 - (x - j)^p-1とすると、 x=jでg(x, j)=1, x≠jでg(x, j)=0
        - つまりa_jが1となるjに対してg(x,j)をf(x)にたしていくと、条件を満たす多項式になる
    - ラグランジュ補間の発想は便利そう
        - (x_1, y_1), (x_2, y_2),...,(x_n,y_n)を通るy=f(x)を因数定理でいい感じに表現
        - 詳細 https://suikaba.hatenablog.com/entry/2019/08/11/021048
        - (x-0)*(x-1)*...*(x-(p-1))を求めたり式の筆算するところはちょっと大変


### abc141

### abc142
- E - Get Everything
    - bitDP

- F - Pure
    - mada
    
    
### ABC143
- E. Travel by Car
    - 概要
        - 重みc付き無向グラフの距離
        - 燃料Lが与えられ、移動するとL-cとなり、足りない場合はLまで補給
        - 補給回数の最小値
    - 解法
        - 補給回数と残燃料のペアをコストにしてダイクストラを全ノードで行う
    - 想定解
        - わーシャルフロイドで全点最短距離求める。
        - 距離がL以下のノード間に1の辺を貼るグラフを構築し、もっかいわーシャルフロイド
        

### ABC144

- E. Gluttony
    - 概要
        - コストF1~Fnと、コストA1~Anでペアを作る
        - ペアの中の fi * Aiの最大値を最小化
        - F1~FnはK個まで減らすことができる
    - 解法
        - 解のにぶたん

- F. Fork in the Road
    - 概要
        - DAGで、各ノードでランダムに辺を選んでゴールまで行くとして、
        - スタートからゴールまでの距離の期待値をEとする
        - DAGの辺をどれか切って、Eを最小化する
    - 解法
        - 後ろからEを計算すると、O(M)でEは計算可能
        - 切る辺は、明らかに辺のうちEが最も悪いノードへの辺 -> n本しかない
        - O(N*M)でいける 
