
## 基本

### 整数系
-  フェルマーの小定理
    - $a^p$ ≡ a (mod p)
    - $a^{p-1}$ ≡ 1 (mod p)

- mを法とする場合での除算
    - A ÷ B = C で、それぞれmod をとってa, b, cだとすると、
    - a * (bの逆元) ≡ c
    - 逆元は b-1 = b**(p-2)で与えられる

### 実装テクニック
- 番兵による線形探索
  - 配列のおわりに答えをおいて、while文でiをincrementすること探索中の比較を1回で住むように

### セグメント木
- 木に関するテクニック集  
https://topcoder.g.hatena.ne.jp/iwiwi/20111205/1323099376

- 理解  
要素とそれをマージする演算がモノイドなら適用可能  
モノイド->演算が結合律を持ち、単位元が存在する
(f(f(a・b)・c) = f(a・f(b・c))であればよく、f(a・e)=aとなるeがいればいい)  
https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html  
http://beet-aizu.hatenablog.com/entry/2019/03/12/171221
 
- 遅延セグ木  
作用素の適用が可換なら伝播させる必要はホントはない。
ex. [a, b) をxにする、は可換でないので伝播させないとだめ。

### グラフ

- LCA（最小共通祖先）
    - 木の２つの頂点間で共通する親頂点のなかで最も低いもの（根から遠いもの）
    - 最初に枝分かれしたところ
- オイラーツアー
    - 根から木をdfsしたときの訪れる順に、辺もしくは頂点の重みを配列にいれる（行きを+、帰りを-)
    - +e1, +e2, -e2, +e3, -e3, -e1
    - ある頂点が最初に現れたidxまでの累積和を取ると、根からその頂点までの辺（頂点）の重みの和になっている。
    
---------- 

## Atcoder Beginner Contest

### abc001
- python3の四捨五入
    - round関数はくそ (切り捨て誤差が小さくなるように偶数になってしまう）
        - round(2.5) -> 2
    - 小数点がずれて怖いときは、評価する方を掛け算してあげる
    - 1123 -> 1120 にしたいとき t -= t % 5
- いもす法
    - 立ち上がりに1、立ち下がりに-1を入れておいて、最後累積和を取ることで >0 なら雨、==0なら晴れになる

### abc002
- 最大クリーク問題
    1. 所詮N = 12だから2**12で回す
    2. クリーク数決めてcombinationであるかないか、というのを友達の数でmaxとって二分探索
    3. for i in range(N) 友達増やしてみて現在の友達全員と友達かどうかを判定
    
### abc003
- 包除原理
    - 結構めんどかった. 
    - たてよこ、たてよこの組み合わせ6通り、 たてよこ３つ選んだとき、たてよこ全部
    - (1, 2, 3, 4) - (0, 1, 3, 6) + (0, 0, 1, 4) + (0, 0, 0, 2)
    - それぞれありうるかどうかの条件も必要

### abc004
- マーブル
    - 時間かかった。できるだけ関数は再利用していこう

### abc005
- imos法
    - N+1*N+1の配列を作っておけばindexが-1の例外処理がいらなくなる

### abc006
- LIS

### abc007
- 桁DP

### abc008
- コイン裏表の枚数の期待値
    - 約数を数え上げ、左側に約数が奇数枚くる確率を計算、確率がそのまま期待値になる。賢い
- 金塊ゲーム
    - メモ化再帰サイコ〜

### abc009
- 漸化式は行列の累乗を利用することでO(logn)で解ける！
- AND、XORを足し算掛け算のように扱う (半環)

### abc010
- ある点から他の点に何処か寄り道してから向かうという問題で、移動距離Lが決まっている場合楕円内にある点にならいける
- Dめちゃむずかった
marked girlのそれぞれの後ろにもう一つノードを設け、ログインできなくする工作をそのノードを切ると見なしそれぞれの工作をまとめる
最小カット最大フロー定理
ford-fulkersonのアルゴリズム
    - 適当に流す。流した流量をdとすると、流した方向のエッジに重みdを足し、逆方向を向くエッジ(capacity 0)に-dを足す (残余ネットワーク)
    - 流せなくなるまで続ける

### abc011
- 貪欲法
- combinationはパスカルの三角形使うと良いらしい

### abc012
- ワーシャルフロイドはpython通らない

### abc013
- 満腹な高橋くん(下からDP、順番関係ないからXによってのみほかが決まる)
- 巡回置換 
巡回の操作も累乗の足し算作戦
リストの削除普通にやると死ぬほど遅いので二分探索

### abc014
- 最小共通祖先 (LCA)
- pythonきびしいな〜

### abc015
- ナップザック亜種
後ろからループ回すことで品物数のループをする際メモリを使いまわせる

### abc016
- D 一刀両断
    - 交点問題
    - 直線を挟んで逆側にあるか -> 片側から見て外積の積が負
    - 線分内に交点があるか、両端からみて外積の積が負

### abc017
- 宝石と魔王ゲーム
    - imos法
- サプリメント
    - dp & imos法　難しかった
    - dp(i) にはi番目のサプリを食べおわったときの組み合わせ

### abc018
- ひし形カウント 難しかった ある方向に関して両側開いてるマス数を保存しておく
- 半分全列挙

### abc019
- 木の直径
    - ある点（なんでも良い）から一番遠い点xからみて一番遠い点yとすると、x-yの距離が直径

### abc020
- ダイクストラ & 二分探索
- 最大公倍数の列挙 むずかった

### abc021
- DAGの数え上げ ダイクストラで最短経路出してからメモ化再帰
    - queue突っ込んだ順に取り出す方式なら、初めて通ったノードは確実に最短経路 
    - 二回目以降は、最短経路と同じなら足す
- nHr

### abc022
- 最短閉路
    - 閉路はスタートのノードを除けば経路になる 
    - ワーシャルフロイドで全点対最短距離を求めておいて、スタートに接続するノードを２つ選ぶ 
    - $O(N^3) + O(N^2)$ \\
    - ダイクストラで最短経路木求めながらスタートから生える枝にIDをつける
    - 最短閉路は
    - ある枝の途中からスタートに帰ってくる場
    - ある枝から他の枝に移動して返ってくる場合のどれか
    - $O(N^2)$
- 天体の膨張
    - 平行移動、回転によって影響を受けない距離の比を考える
    - 全天体の距離の総和、最近点の長さ、最遠点の長さ、重心からの最近点、最遠点の距離

### abc023
- 収集王
    - 縦横の和がある数字に まとめてから
- 射撃王
    - 最小化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

### abc024
- 民族大移動
    - 貪欲法
- フェルマーの小定理

### abc025
- ゲーム木探索
- 25個の整数
    - 難しかった

### abc026
- 数値計算の二分探索

### abc027
- ロボット
    - ある時刻において右に動いた場合の将来的な収支は計算できる
    - 高い順に並べて低いところで左に行けばいい

### abc028
- 特になし

### abc029
- 特になし

### abc030
- 特になし

### abc031
- 語呂合わせ
    - 文字数先に決めてしまって確認

### abc032
- ある積以下の最長部分列
    1. 1は積に影響しないのでまとめる, 10**9は実は掛け算だとO(logN)だからそんな大したことない 
    2. 尺取法 O(N)
    3. logとると和になるので、累積和が使える。長さｘを二分探索 O(NlogN) (誤差めんどくさそう）
    4. 現在の最大の長さ以下の探索はしなくてよいので、尺取法において一つ減らすだけで良い
- ナップサック
    - 価値でDP
    - n少ないがW,Vに上限がない場合 ２つに分けて全組み合わせ列挙 -> いらないのはぶいてそれぞれいい感じに突き合わせる（二分探索）

### abc033
- abc簡単
- 鈍角、直角三角形


### abc034
- (n-1)^1+1
- 最大化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

### abc035
- 有向グラフにおける行きと帰りの最短距離 -> 帰りは矢印を逆にしてダイクストラ

### abc036
- treeDP
    - いい問題だった。自分が白の組み合わせと、どちらでもいい組み合わせの漸化式

### abc037
- pythonおせえ〜

### abc038
- BIT, LIS
    - (i&-i) で rightmost set bit だけ取り出せる

### abc039
- 特になし

### abc040
- union-find木

### abc041
- bitDP, 2**nのDP

### abc042
- 行けない場所があるときのグリッドの経路組み合わせ

### abc043
- アンバランス

### abc044
- 選んだ合計の平均がA -> それぞれの要素を x - A とすると合計が0になればいい


### abc046
- E - AtCoDeerくんと立方体づくり
    - 概要
        - 4隅に色がついている正方形がたくさん
        - 正方形を6枚えらんで立方体をつくる。接する頂点の色は同じである必要。
        - 立方体が何通りあるか
        - 回して一致するなら同じ立方体とする
    - 解法
        - 上面を一番小さい数にして向きも固定すれば、まわして一致のダブルカウントを防げる
        - 下面と向きを固定すると頂点の色が確定する
        - 横の面の組み合わせを考える。
        - 上面と下面と同じやつを使ったらだめで、横には一種類しか使ったらだめ
        - 色の組み合わせをmapでもって、使った正方形を回した4組をmapから消す。
        - 4色をmapのキーにするときpairでやっちゃったけど、ハッシュ化したほうが良い 

### abc052
- N!の約数の総数

### abc122

- C - GeT AC
    - Sの[l, r)の'AC'の数。累積和のもちかた、ちょっと考える必要
- D - We Like AGC
    - 以下の長さNの文字列の数
        - AGCTしか含まない。
        - AGCを部分文字列として含まない。
        - 隣り合う文字をswapしても上記を満たさないといけない
    - dp[i][s1][s2][s3] : i番目まで見て, 先頭3文字が s1s2s3の数
    - 丁寧にAGCを含まない場合を処理していくだけ。
     
### abc124
- D - Handstand
    - 概要
        - 0 or 1からなる文字列
        - [l,r)の0,1をすべてひっくり返すをK回行える、連続して1が続く長さを最大化
    - 解法
        - 010011100011
        - 連続する0をひっくり返す操作を、K箇所続けて行うのが一番良さそうなのがわかる
        - 連続する0, 1の数の配列のK個の連続部分和をN-K通り試す。
    - 工夫
        - 1100110011のように1が外側にあるとしたほうが扱いやすいので、
        端が0でも、1が0個あるという風にした。
   
### abc125
- C - GCD on Blackboard
    - 概要
        - A1 ~ An (Aは自然数)
        - どれか1つを自由に書き換えたあとのすべて数の最大公約数の最大値
    - 解法
        - 肝は gcd(A,B,C) = gcd(gcd(A,B), C) であること
        - 想定解
            - L[i], R[i]をずらしていく。L[i]は左からi番目までの最大公約数で、R[i]は右から。
            - 書き換える、というのをgcdの計算に入れない、という発想
        - 自分解
            - セグ木で、ノードのマージをgcdにした。
            - gcd(a,0) = aなので、単位元が0になって割ときれいに解けた。
            - 各Nに対して、0にセット->根クエリ->もとの値セットで最大値探索
            
- D - Flipping Signs
    - 概要
        - A1 ~ An (Ai は負もある)
        - 連続する2つに-1をかける操作を好きなだけして、和を最大化する
    - 解法
        - -10, 5, -4
        - 負の数が偶数なら、結局全部正にできて、奇数なら1個だけ負になるようにできる
        - 奇数のとき sum(A) - 2 * min(abs(A))でOK

### abc126
- D - Even Relation
    - 概要
        - 重み付き木を白黒に塗り分けて、
        - 同じ色の距離が偶数になるように
    - 解法
        - uとvの距離は、du + dv - 2 * d_lca
        - ３項は偶数なので、du + dvが偶数 -> 適当に根決めて距離が偶数、奇数で塗り分ければ良い。        

- E - 1 or 2
    - 概要
        - A1 ~ An (A=0,1)
        - Xq, Yq番目の和がわかる、という情報がQ個
        - 何枚のカードをめくればすべての情報がわかるか
    - 解法
        - 1,2の和がわかって、2,3の和がわかってれば、1,2,3のどれかがわかれば他がわかる
        - つまりUnionFindで結合していって、素集合の数が答え

- F - XOR Matching
    - 概要
        - 0 ~ 2^Mの数を2こずつ含む数列で、
        - 同じ値の間に含まれる数のxorがすべてKとなるような数列の構築
        - ai == ajのとき、 ai xor ai+1 xor ... xor aj = K
    - 解法
        - a xor a = 0
        - a,b,c,d,e,K,e,d,c,b,a,K
        - ってやれば、a-a,b-b,...,e-eについて間のxorは打ち消しまくってKが残る
        - K~Kの間はa,b,c,d,e,K,Kのxorだが、0~2^M-1のすべてのxor(=X)とKのxor
        - Xは各bit見たときちょうど0と1が2^(M-1)回出るはずなので、必ず0
        - つまり、全ての数に対して間のxorがKになる
        
### abc127

- E - Cell Distance
    - 概要
        - NxMのマス目にK箇所にコマをおいたときの、全てのコマ間距離の総和の、全ての置き方に対する和
    - 解法
        - ある1マスxに関連する距離の和をまず考える
        - xとaにコマが置かれるのは、その2マスを除いてK-2コマ分選ぶので、N*M-2 C k-2
        - これはxから見て、全てのマスa=1~NMに対して成り立つので、
        - N*M-2 C k-2 * （xから全マスへのマンハッタン距離の和)
        - 実は、全てのマスに対してこれは成り立つので、
        - N*M-2 C k-2 * Σ_x_N（xから全マスへのマンハッタン距離の和) / 2
        - が答え
        
- F - Absolute Minima
    - aのmedianがmin_xとなる。
    - 最小値を取り出すpriority_queueと最大値を取り出すpriority_queueをごちゃごちゃする。

### abc128
- E - Roadwork
    - 概要
        - N個工事があり、Si ~ Ti の時刻, 座標Xiを通行止めにする
        - M人が時刻D[i]から時速1で移動し、通行止めにあたったら止まる。止まる距離を答える
    - 解法
        - S-X, T-Xにしたほうが扱いやすい
        - Sでソートすると、D[i]を考えるときに、すでに始まってる工事を取り出せる
        - すでに始まってる工事を、xが近い順に取り出せるpriority_queueにつっこんでおく。
        - すでに始まってる工事の中で、一番近い工事を取り出し、まだ終わってなければそこで終了。
        もうTよりD[i]が大きく、終わっていたら、popして次に近い工事を取り出す。
        
- F - Frog Jump
    - 概要
        - A進む->B戻る->A進む->B戻る　を繰り返して、蓮にある点数を取得、すでに訪れたところに行ってはいけない。
        - 得点の最大化
    - 解法
        - A, A-B, 2A-B, 2A-2B -> A-BをCとすると、
        - A, C, A+C, 2C, A+2C, 3C, ... , A+kC　となりキレイ。
        - A + kC = N − 1 なので、Cとkで全探索できる。
        - さらに、k, Cのときの得点をf(k, C)とすると、
        - f(k+1, C) = f(k, C) + S_(N-1-kC) + S_kC なので, f(k, C)の計算はO(1)
        - 調和級数 Σ_k n/k ~ O(nlogn)なので、k, Cの全探索は O(nlogn)なので間に合う
              
### abc129
- E - Sum Equals Xor
    - 概要
        - a + b <= L
        - a + b = a xor b
        - となるa,bの組み合わせの数
    - 解法
        - i番目のbitで、Lより真に小さいか、否かを持ちながら上位bitから桁dp
        - ab=00, 01, 10が選べる。

- F  Takahashi's Basics in Education and Learning
    - 数列の遷移を行列の掛け算で表現することで、数列のN番目の要素をlogNで求める

### abc130
- E - Common Subsequences
    - レーベンシュタイン距離的な感じ。
    
- F - Minimum Bounding Box
    - xmaxに着目
    - xmaxになりうる点の候補は、L, R, U, Dの方向を向いているうち一番xが大きいもの (xmax_candidate)
    - t秒立った時点で、 xmax = max(L_xmax - t, R_xmax + t, U_xmax, D_xmax)
    - xmaxは下に凸の折れ線となることがわかる ＼_／ こんな感じ
    - xmax, xmin, ymax, yminそれぞれ同じこと。
    - ここで、面積が最小となるのは、xmax, xmin, ymax, yminの極小点（折れ線の頂点）のどれかだとわかる。
    - この極小点はせいぜい12個しかないため、全部試せばOk

### abc131
- E - Friendship
    - 概要
        - N頂点グラフで、距離が2となるような頂点i,jの組がちょうどK個になるものの構築
    - 解法   
        - うにをつくると、N-1C2がすべて距離2になる。
        - うにの各頂点間を１本つなぐと、距離2の組み合わせが1つ減る。
        - N-1C2 - K 本つなげばOK
        
- F - Must Be Rectangular!
    - 頂点間でx, yのどちらかが一致していたら辺が張られるようなグラフを考える。
    - 求める答えは、このグラフ上での各連結成分内の (xの値の種類 * yの値の種類 - 頂点の数)の和

### abc132
- D - Blue and Red Balls
    - 赤、青のボールの組み合わせ

- E - Hopscotch Addict
    - けんけんぱでダイクストラ
    - 各頂点に0,1,2の状態をもたせ、接続している頂点で自分の状態+1に遷移できるダイクストラ 
    
- F - Small Products
    - 数列の末尾がaだったとき、次の要素の取りうる範囲は 1 ~ floor(n/a)
    - 列挙してみると、n/b+1 ~ n/b では、次の要素の取りうる範囲が1 ~ bで変化しない
    - bの取りうる値は、2*√n 通り 。
    - いい感じにまとめてあげればO(√n・K)で解ける
    
### abc133
- D - Rain Flows into Dams
    - 数式建てると一周して方程式になるので、一意に決まる

- E - Virus Tree 2
    - 考えるだけっちゃ考えるだけ
    
- F - Colorful Tree   
    - 概要
        - 	辺の色と重みがついていて、根からある頂点までに現れる、特定の色の辺の数、重みの和を計算する必要がある
        - 	色と頂点を配列で持つと、空間計算量が O(N^2)になる。
    - 解法1
        - 	オイラーツアーを色ごとにリストで管理して空間計算量をO(N)に落とす。
        - 	元のオイラーツアーでの出現箇所のidxと重みのタプルを保持することで、根から頂点までの各色の重みを二分探索で計算 O(QlogN)
    - 解法2
        - クエリを先読みして、DFSしながら訪問中に頂点分の各色の重みを保持し、解答に必要な部分の計算をその時点で行う O(N+Q)

### ABC134

- D - Preparing boxes
    - 概要
        - a1 ~ aNが与えられる
        - 1~Nの任意の整数iの倍数が書かれた箱に入っているボールの個数の和を 2 で割った余りが ai である
        - これを満たすb1~N  bi=(0 or 1)があるかどうか
    - 解法
        - 後ろから貪欲に0か1を決めていく。

- E - Sequence Decomposing
    - 概要
        - AiとAjが同じ色で塗られているならAi < Aj
        - を満たすように色を塗るときの最小の色の数
    - 解法
        - Longest Decreasing Sequenceを解くだけ。
        - 負にしてLIS貼れば終わり。
                       
- F - Permutation Oddness
    - 箱根駅伝DP と呼ばれるもの
    - ペアリングによって値が決まるとき、今までにペアリングを保留している要素の数、を管理することできれいにDPが決まる。


### ABC137

- D: Summer Vacation
    - M日後の報酬が最大となるA日後にB円もらえるバイトのうけかた 
    - なんか結構時間くった
    - 後ろから受けられるバイトの候補を増やしながら候補の中で最大報酬をうける
    - 候補を増やすpriority queueと、候補の最大のためのpriority queue
    
- E - Coins Respawn
    - 1分かかる辺を、辺のコインを拾いながら目的地に向かい、T分 * P枚のペナルティを払ってゲーム終了
    - コインの枚数をc - pとしてベルマンフォード
    - 目的に向かわない負閉路をNGにしてしまってみすってた
    - あと勝手に同じu, vの辺のコインを足してしまってたけど、別の辺がある扱いだった。。
    
- F - Polynomial Construction
    - f(x) = Σ_0~p-1 b_i * x^i　として、
    - f(j) == a_j (j=0~p-1)を満たすb_iを求める。a_j = [0, 1]
    - 想定解はかなりきつい
        - フェルマーの小定理からa^p-1≡1 より、
        - g(x, j) = 1 - (x - j)^p-1とすると、 x=jでg(x, j)=1, x≠jでg(x, j)=0
        - つまりa_jが1となるjに対してg(x,j)をf(x)にたしていくと、条件を満たす多項式になる
    - ラグランジュ補間の発想は便利そう
        - (x_1, y_1), (x_2, y_2),...,(x_n,y_n)を通るy=f(x)を因数定理でいい感じに表現
        - 詳細 https://suikaba.hatenablog.com/entry/2019/08/11/021048
        - (x-0)*(x-1)*...*(x-(p-1))を求めたり式の筆算するところはちょっと大変




 