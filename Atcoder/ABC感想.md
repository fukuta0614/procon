
## Atcoder Beginner Contest

### abc001
- python3の四捨五入
    - round関数はくそ (切り捨て誤差が小さくなるように偶数になってしまう）
        - round(2.5) -> 2
    - 小数点がずれて怖いときは、評価する方を掛け算してあげる
    - 1123 -> 1120 にしたいとき t -= t % 5
- いもす法
    - 立ち上がりに1、立ち下がりに-1を入れておいて、最後累積和を取ることで >0 なら雨、==0なら晴れになる

### abc002
- 最大クリーク問題
    1. 所詮N = 12だから2**12で回す
    2. クリーク数決めてcombinationであるかないか、というのを友達の数でmaxとって二分探索
    3. for i in range(N) 友達増やしてみて現在の友達全員と友達かどうかを判定
    
### abc003
- 包除原理
    - 結構めんどかった. 
    - たてよこ、たてよこの組み合わせ6通り、 たてよこ３つ選んだとき、たてよこ全部
    - (1, 2, 3, 4) - (0, 1, 3, 6) + (0, 0, 1, 4) + (0, 0, 0, 2)
    - それぞれありうるかどうかの条件も必要

### abc004
- マーブル
    - 時間かかった。できるだけ関数は再利用していこう

### abc005
- imos法
    - N+1*N+1の配列を作っておけばindexが-1の例外処理がいらなくなる

### abc006
- LIS

### abc007
- 桁DP

### abc008
- コイン裏表の枚数の期待値
    - 約数を数え上げ、左側に約数が奇数枚くる確率を計算、確率がそのまま期待値になる。賢い
- 金塊ゲーム
    - メモ化再帰サイコ〜

### abc009
- 漸化式は行列の累乗を利用することでO(logn)で解ける！
- AND、XORを足し算掛け算のように扱う (半環)

### abc010
- ある点から他の点に何処か寄り道してから向かうという問題で、移動距離Lが決まっている場合楕円内にある点にならいける
- Dめちゃむずかった
marked girlのそれぞれの後ろにもう一つノードを設け、ログインできなくする工作をそのノードを切ると見なしそれぞれの工作をまとめる
最小カット最大フロー定理
ford-fulkersonのアルゴリズム
    - 適当に流す。流した流量をdとすると、流した方向のエッジに重みdを足し、逆方向を向くエッジ(capacity 0)に-dを足す (残余ネットワーク)
    - 流せなくなるまで続ける

### abc011
- 貪欲法
- combinationはパスカルの三角形使うと良いらしい

### abc012
- ワーシャルフロイドはpython通らない

### abc013
- 満腹な高橋くん(下からDP、順番関係ないからXによってのみほかが決まる)
- 巡回置換 
巡回の操作も累乗の足し算作戦
リストの削除普通にやると死ぬほど遅いので二分探索

### abc014
- 最小共通祖先 (LCA)
- pythonきびしいな〜

### abc015
- ナップザック亜種
後ろからループ回すことで品物数のループをする際メモリを使いまわせる

### abc016
- D 一刀両断
    - 交点問題
    - 直線を挟んで逆側にあるか -> 片側から見て外積の積が負
    - 線分内に交点があるか、両端からみて外積の積が負

### abc017
- 宝石と魔王ゲーム
    - imos法
- サプリメント
    - dp & imos法　難しかった
    - dp(i) にはi番目のサプリを食べおわったときの組み合わせ

### abc018
- ひし形カウント 難しかった ある方向に関して両側開いてるマス数を保存しておく
- 半分全列挙

### abc019
- 木の直径
    - ある点（なんでも良い）から一番遠い点xからみて一番遠い点yとすると、x-yの距離が直径

### abc020
- ダイクストラ & 二分探索
- D LCM Rush
    - 概要
        - Σ{i..N} LCM(i, K)
        - N, K < 10^9
    - 解法
        - 前提として、LCM(a,b)=a*b/gcd(a,b)なのでgcdを基本に考える
        - 部分点 (K < 100)
            - gcd(i, K) = gcd(i, K+i)なので、mod K はすべてgcd同じ
            - 0..K-1までの各iで、(i,i+K,..,i+(n-1)K) * K / gcd(i, K)すればいける
        - 満点
            - gcdの取りうる値は、Kのすべての約数
            - gcd(i, K) = dとなる iの和 (i < N)を求めることができたら、すべてのdで足せば答え
            - gcd(i, k) = 1となる iの和 (i < n))
                - 例えばn=6, k=6だとすると、
                - 全部 - (2で割り切れる) - (3で割り切れる) + (2, 3で割り切れる)
                - となるので、kを素因数分解して、包除原理で和を求めることができる
            - gcd(i, K) = dとなるiの和 (i < N)
                - = gcd(i, K/d) = 1 となるiの和(i < N/d))
                - となるので、これを繰り返せばOK
    - まとめ
        - lcmをgcdの問題に変える
        - gcdがある値dになるようなi、が何個あるかをそれぞれ考える
        - 素因数を列挙して包除原理すると、互いに素な数の和を求めることができる
        - 各gcdに関して、N,Kを割り算することで互いに素な数の和に帰着できる

### abc021
- DAGの数え上げ ダイクストラで最短経路出してからメモ化再帰
    - queue突っ込んだ順に取り出す方式なら、初めて通ったノードは確実に最短経路 
    - 二回目以降は、最短経路と同じなら足す
- nHr

### abc022
- 最短閉路
    - 閉路はスタートのノードを除けば経路になる 
    - ワーシャルフロイドで全点対最短距離を求めておいて、スタートに接続するノードを２つ選ぶ 
    - $O(N^3) + O(N^2)$ \\
    - ダイクストラで最短経路木求めながらスタートから生える枝にIDをつける
    - 最短閉路は
    - ある枝の途中からスタートに帰ってくる場
    - ある枝から他の枝に移動して返ってくる場合のどれか
    - $O(N^2)$
- 天体の膨張
    - 平行移動、回転によって影響を受けない距離の比を考える
    - 全天体の距離の総和、最近点の長さ、最遠点の長さ、重心からの最近点、最遠点の距離

### abc023
- 収集王
    - 縦横の和がある数字に まとめてから
- 射撃王
    - 最小化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

### abc024
- 民族大移動
    - 貪欲法
- フェルマーの小定理

### abc025
- ゲーム木探索
- 25個の整数
    - 難しかった

### abc026
- 数値計算の二分探索

### abc027
- ロボット
    - ある時刻において右に動いた場合の将来的な収支は計算できる
    - 高い順に並べて低いところで左に行けばいい

### abc028
- 特になし

### abc029
- 特になし

### abc030
- 特になし

### abc031
- 語呂合わせ
    - 文字数先に決めてしまって確認

### abc032
- ある積以下の最長部分列
    1. 1は積に影響しないのでまとめる, 10**9は実は掛け算だとO(logN)だからそんな大したことない 
    2. 尺取法 O(N)
    3. logとると和になるので、累積和が使える。長さｘを二分探索 O(NlogN) (誤差めんどくさそう）
    4. 現在の最大の長さ以下の探索はしなくてよいので、尺取法において一つ減らすだけで良い
- ナップサック
    - 価値でDP
    - n少ないがW,Vに上限がない場合 ２つに分けて全組み合わせ列挙 -> いらないのはぶいてそれぞれいい感じに突き合わせる（二分探索）

### abc033
- abc簡単
- 鈍角、直角三角形


### abc034
- B - ペア
    - 100 -> 101, 101 -> 100 n^1
    - 99 -> 100, 100 -> 99 (n-1)^1+1
- D 食塩水
    - 最大化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

### abc035
- 有向グラフにおける行きと帰りの最短距離 -> 帰りは矢印を逆にしてダイクストラ

### abc036
- treeDP
    - いい問題だった。自分が白の組み合わせと、どちらでもいい組み合わせの漸化式

### abc037
- pythonおせえ〜

### abc038
- BIT, LIS
    - (i&-i) で rightmost set bit だけ取り出せる

### abc039
- 特になし

### abc040
- union-find木

### abc041
- bitDP, 2**nのDP

### abc042
- 行けない場所があるときのグリッドの経路組み合わせ

### abc043
- アンバランス

### abc044
- 選んだ合計の平均がA -> それぞれの要素を x - A とすると合計が0になればいい

### abc045
- D - すぬけ君の塗り絵 / Snuke's Coloring
    - 概要
        - H*WのマスのN個を黒く塗られている
        - 全3x3の領域でk個塗られているものが何個あるかをk=0~9まで数える
    - 解法
        - H,Wが10^9なので普通には無理。
        - 座標圧縮したくなってしまったけど、x,yが単調増加でずっとあると、圧縮後もそれぞれ10^5あるから無理だった。
        - 関係あるのは黒く塗られているところなのでその周辺を見ればいい。
        - 近くに黒丸が２つあるとダブルカウントしかねないので覚えておく。

### abc046
- C - AtCoDeerくんと選挙速報
    - ある値bを超えるようなaの倍数を求めるだけ
    - max(((t + T[i] - 1) / T[i], (a + A[i] - 1) / A[i]))
    
- D - AtCoDeerくんと変なじゃんけん
    - グーを出した回数しかパーを出せないじゃんけんの戦法
    - 相手も同じ戦法になってることに気づくのに時間かかった。
    - 相手が無駄にグーを出してる数だけが重要。
    
- E - AtCoDeerくんと立方体づくり
    - 概要
        - 4隅に色がついている正方形がたくさん
        - 正方形を6枚えらんで立方体をつくる。接する頂点の色は同じである必要。
        - 立方体が何通りあるか
        - 回して一致するなら同じ立方体とする
    - 解法
        - 上面を一番小さい数にして向きも固定すれば、まわして一致のダブルカウントを防げる
        - 下面と向きを固定すると頂点の色が確定する
        - 横の面の組み合わせを考える。
        - 上面と下面と同じやつを使ったらだめで、横には一種類しか使ったらだめ
        - 色の組み合わせをmapでもって、使った正方形を回した4組をmapから消す。
        - 4色をmapのキーにするときpairでやっちゃったけど、ハッシュ化したほうが良い 

### abc047

- B	すぬけ君の塗り絵 2 イージー / Snuke's Coloring 2 (ABC Edit)
    - 領域狭めてくやつ
    - 超愚直に塗ったが、白の領域は内部の長方形なのでl,r,u,dを覚えておけばよかった。
    	
- C	一次元リバーシ / 1D Reversi	
    - 文字列の変化点をかぞえるやつ
    
- D	高橋君と見えざる手 / An Invisible Hand
    - 問題設定ややこしい。
    - 結局i,jのペアでaj-aiが最大となるやつの組み合わせの数。
    - なぜか二分探索木で最大を求めてmx-aiで求めたが、最小値を覚えながらai-minでよかった。

### abc048

- C	Boxes and Candies
    - 概要
        - 配列の隣り合う要素の和がxを超えないように、各要素を引く。引く必要のある合計
    - 解法
        - はじっこより真ん中を引くほうが絶対良いので、貪欲
        - 一回WA
            - 要素を0未満にはできないのが漏れていた
            - 0未満にしないといけない場合は、すでに考慮した左側のやつから引く。
            - x>=0なので、左を引ききってもだめな場合はない。
        
- D	An Ordinary Game
    - 概要
        - 文字列から文字を消していく。消したあとに隣り合う文字が同じになる場合は消せない。
    - 感想
        - つらかった。
        - 消す順番によって結果が変わるような気がしてしまいこんがらがってとけず。
    - 解法 
        - 最終状態は、abababa もしくは abababになるのは間違いない。
        - うまく順番変えれば真ん中のやつは消せるなぁとか考えてたけど、消せても2個単位なので、勝敗には関係ない。
            - ここがわからなかった。
        - つまり、最終状態の文字数の遇奇は確定してるので勝敗も確定している
        

### abc049
- C	白昼夢 / Daydream
    - dream, dreamerで作られた文字列か判定
    - 前から見ると分岐が生じるので後ろから見る
    - 後ろのidxを持ってsubstrしたが、全部ひっくり返して前から見る作戦もある。
- D	連結 / Connectivity
    - 線路による連結成分と、道路による連結成分がそれぞれある。
    - どちらでも連結していることの判定
    - UnionFindをふたつもって、rootのidxのペアが一致していれば連結していると言える。
    - ペアをmapでもてば、どちらでも連結している都市の数がわかる。

### abc051
- C	Back and Forth
    - 点から点へ向かう4通りの矢印書いていくだけ。
    - 正負の処理の共通化を少しきれいに書けた。
    
- D	Candidates of No Shortest Paths
    - 最短経路としてつかわれない辺の数
    - ワーシャルフロイドして、全点間最短距離を出しておく。
    - dist[i][j] < edge[i][j]だったらその辺は使うことはない。
    - 逆にそうでなければ、少なくともそのi, jの最短経路に使うのでOK。(等号の場合も同じ)
    - つまりこれだけ。解説より簡単そう。

### abc052
- C - Factors of Factorial
    - N!の約数の総数

- D - Walk and Teleport
    - 歩いて移動するか、テレポートするか
    - 結局隣に歩くかテレポートしかないので、貪欲

### abc055
- C	Scc Puzzle
    - めっちゃかんたん 
    
- D	Menagerie
    - 概要
        - 動物が円環上に並んでる
        - 正直者、嘘つきのどちらかわからない動物が、それぞれ、自分の両隣が同一か異なるかを答えているのが与えられる
        - 矛盾しない組み合わせがあるかどうか
    - 解法
        - ２匹の正直or嘘つきを仮定すると、自動的にすべての組み合わせが決まる。
        - 最後まで求めたときに最初の仮定と矛盾しなければOK。
        - 2匹の組み合わせを4通り試すだけ

### abc056

- C	Go Home
    - 問題
        - 時刻iに、x-i, x, x+iに移動できる
        - Xにたどり着く最小の時刻
    - 解法
        - n*(n+1)/2 >= xを満たす最小のnを考える
        - どこかの時刻tで戻った場合は、n*(n+1)/2 - 2*t, stopなら n*(n+1)/2 - t
        - という感じで調整ができる。
        - n*(n+1)/2 - x < n　なので、この調整でどうにかなるので n が答え
    
- D	No Need
    - 問題
        - 総和がK以上になる部分集合を良い集合という
        - カードiを含むよい集合のうち、iを除くと総和がK未満になってしまうものがない ⇛　カードiは不要
        - 不要なカードの枚数を求める
    - 解法
        - カードiを使わずに取りうる和は、dpでO(NK)で求まる
        - K-a[i] ~ Kの和のうちどれかを作れるなら、カードiがあるおかげで良い集合になるような部分集合があるということ
        - どうやったら戻すDPができるかなーと考え、よくわからず、
        - 明らかに、大きいカードのほうが必要なので単調性があるので、にぶたんで上記を毎回やった。
        - O (NKlogN)
    - かっこいい解法
        - 0 ~ iまでを使った時点での取りうる和のdp配列と、
        - N ~ iまでを使った 時点での取りうる和のdp配列　をもっておけば、
        - 各iを使わなかった場合の取りうる和をO(K)で求められる。
            - やや語弊があり、0-i, i-Nの和で K-A[i]~Kのものがあるかどうかがわかる
        - この場合O(NK)
        


### abc058

- C - 怪文書
    - 各文字列の中で、各文字の出現回数が最小のものの数をもとめ、足すだけ

- D - 井井井 / ###
    - 概要
        - 縦n本、横m本の直線から作られるすべての長方形の面積の総和
    - 解法
        - 縦、横は独立で考えることができる。
        - 各辺が何回使われるか、を求めて、それの縦と横をかければいい
        - 真ん中のほうがいろんな幅で何度も使われる、的なルールからがんばって数式求めた
        - n=7, k=1だと、1111111, k=2だと1222221という感じなので、
            - 1,2,3.. (k(k+1/2))を両端分と、真ん中がkがn-2k個 (あとから見返して自分のコードが理解できなかったのでメモ)
    - 解法2
        - 幅に変えたが、座標のまま扱ったほうが簡単そう
        - 座標だと、sum (xi - xj) (0<i<j<n)
        - 座標xkが、左側に出てくる回数と右側に出てくる回数は、それぞれk-1, n-kとわかる
        - つまり、sum( (k-1) * xk - (n-k) * xk) 0<k<n をやるだけ
    - やらかし
        - 自分のmodintライブラリ、long longとの+=がおーばーろーどされておらず、
        intの +=が使用されていた？のかうまく通らなかった。。
        

### abc059
- C. Sequence
    - 概要
        - すべてのiに対して、ai+1までの和の符号がaiまでの和の符号と異なるようにする。
    - 解法        
        - 1番目を正にするか、負にするかを２通り試す。
        - 決めたら、和をとって前回値と同じだったら+1か-1まで変更する。
        - iの値の変更とi+1の値の変更が結局同じなので、貪欲にいける。
    
- D Alice&Brown
    - 概要
        - X,Yの数があり、かたっぽから2i引いて、もうかたっぽにi足す
        - 操作ができなくなったら負け
    - 解法
        - (0,1),(0,0),(1,0),(1,1)が負け 
        - 操作により、X-Yは3iずれる。
        - 実験すると、|X-Y| < 1のとき、負けっぽい
        - X-Y>1 && X-Y ≡ 1のとき X-Y=1にできる
        - X-Y>1 && X-Y ≡ 2のとき X-Y=-1にできる
        - 的な感じで, |X - Y| > 1なら、|X - Y|=-1,0,1のどれかにできる。
        - 結局初手が|X-Y|が1より大きいからそうでないかでわかる 

### abc060

- D - Simple Knapsack
    - 概要
        - ナップザック
        - N < 100, W < 1e9, V < 1e9
        - Wの取りうる値は x, x+1, x+2, x+3の4種類のみ
    - 解法
        - N個全ての組み合わせの、Wの和の取りうる値は、
            - x~x+3, 2x~2x+6, ... Nx~Nx+3N
            - 4+7+..+3N+1 =  N * (3N+5) / 2なので、N=100でも10000程度
        - なので、dpを配列でなくmapで管理すれば、N * 10000なので間に合う
    - 解法2
        - 重さが4種類しかないので、勝ちごとにソートしておくと
        - どの重さから何個使うか、を決めると価値が大きいから使うのが最適
        - (N/4)^4で全探索できるので、どの重さから何個使うかを全部調べていける

### abc061
- C - Big Array
    - 概要
        - 数aをb個加える、をn回やったあとに、k番目に大きい数を求める
        - n, bが10^5なので配列の数は10^9となる
    - 解法
        - aを小さい方から足せばOK
    
- D - Score Attack
    - ベルマンフォードで終わり。

### abc062

- C : Chocolate Bar
    - 概要
        - H, Wの長方形を3つの長方形にわける
        - Smax - Smin の最小値
    - 解法
        - 普通に考えると結構むずい
            - W/3あたりを何個か試す感じになるのかな
        - どこで切るか決めると、残った長方形の切り方は、真ん中で切るのが絶対良い
            - h, wのどちらかが偶数だったらきれいになって終わり
            - どっちも奇数だったら、h,wの小さい方の辺をかたっぽに割り当てるのが差が小さい

- D : 3N Numbers
    - 概要
        - 3Nの配列から、N個取り除いて、前半N個の和 - 後半N個の和の最大値
    - 解法
        - k番目の左を前半、右を後半と決めると、それぞれ小さい、大きいものを削除するのが最適とわかる
        - priority_queueで、最大、最小を管理しながら、独立にk番目まで左側、としたときの最適値を計算していけばおｋ 

### abc065

- D - Built?
    - 概要
        - N個の街が2次元平面上にある
        - 座標(a,b)<->(c,d)間を行き来する道を作るにはmin(|a-b|, |c-d|)コストがかかる
        - すべての街を行き来できるようにするための最小のコスト
    - 解法
        - min(|a-b|, |c-d|)とあるが、|a-b|, |c-d|でそれぞれ作っても最小全域木で小さい方は消えるので、どっちも作って良い
        - 全2点間に道を作って最小全域木を作るとO(N^2)
        - x<y<zとして、(0, x), (100, y), (200, z)の街があったとして、
            - |x-z| = |x-y| + |y-z|なので、街1, 3に道を貼る必要はまったくないとわかる
        - ので、x方向、y方向にそれぞれ一番近い街に貼った道を候補として、最小全域木すればOK

### abc066

- D - 11
    - 概要
        - 1..nからなり、長さn+1個の数列A
        - k個の部分列の個数
            - 部分列が同じだったら、取り出す位置が異なっても1個とする
    - 解法
        - 1つの整数だけ、2回出てくる
            - --- x ----- x ----
        - 方針として、全体から、2回出てくるやつのせいで部分列がおなじになってるやつを引く
        - 真ん中を選ぶ場合は、同じにならない
        - 左、右からk-1個選んで、xを選ぶ場合、xのどっちをとっても同じ部分列になる
        - つまり 全体 n+1 C k  - L+R C k-1 が答え             
    
### abc067

- D - Fennec VS. Snuke
    - 概要
        - 木のあるマスが黒、あるマスが白、それ以外は塗られていない
        - 先手は、黒の隣接マスを黒く、後手は白の隣接ますを白く
        - どっちが勝つか
    - 解法
        - なんか最初に説いたときLCAとかやってて馬鹿
        - 白、黒をつなぐ最短経路をそれぞれ塗っていくのがお互い最適
            - それ以外は後でいつでも塗れる
        - 更に考えると、結局、あるマスは、初期の黒、白に近い方の色になる
        - それぞれからDFSして距離求めたら、終わり。          
    
### abc070

- D - Transit        
### abc071

- D - Coloring Dominoes
    - 2 * Nマスに、敷き詰められたタイルの色の塗り分け方
    - タイルは2x1, 1x2しかない。
    - タテ->タテ: 2、タテ->ヨコ: 2, ヨコ->タテ: 1, ヨコ->ヨコ: 3 通り濡れる
    - 書くだけ。
    

### abc100

- C	*3 or /2
    - 2で割れる回数を求めるだけ。
    - 貪欲に2で割っていって求めたが、二分探索で割れなくなる数を求めるとさらに高速化できる。
    
- D	Patisserie ABC
    - N個のケーキがあり、x, y, zの3つの指標がある。(それぞれ負もある)
    - M個食べて、x,y,zの合計の絶対値の最大値
    - 普通にやるとむずいので、x,y,zそれぞれについて、正の方向で最大化するのか、負の方向で最大するのか、8通り全部調べる。

### abc102

- C	Linear Approximation
    - |ai-b|が最小となるbを求める
    - bがaiのmedianのとき最小なので、ソートして終わり
    
- D	Equal Cut
    - 数列を4つに分割して、それぞれの和P,Q,R,Sの最大値と最小値の差の最小
    - P,Qの差の最小化だけを考えるなら、P+Q/2に近いところで切るのが最適。
        - これは累積和でにぶたんすればlogN
    - つまり、Q,Rをどこで切るかを全探索して、P,QとR,Sの切れ目は貪欲で決まる
    - P+Q/2に近いところできる実装がめんどかった。**まだいい感じの実装わかってない**


### abc103

- C	Modulo Summation
    - f(m) = m % a_1 + ... + m % a_n
    - f(m)の最大値
    - m = a_1 x ... a_n - 1とすると、それぞれの項でa_i-1にできるので最大。
    
- D	Islands War
    - 島aと島b間が行き来できないようにはしを落とす。
    - 区間スケジューリング
    - bでソートして、すでにa以降で橋を落としていればそのまま、そうでなければ落とす貪欲
    



### abc104

- C all green
    - 間違えた。。。
    - にぶたんしたくなるが、全完するセットをbit全探索
        - にぶたんで、全完した場合の一問あたりの得点と全完しない場合の得点を同じリストにいれて貪欲した
        - Aが全完可能の場合で、その次に選ぶ全完しない問題の得点が低い場合がある
        - その場合、Bを全完してAをちょっと解くほうがいい場合がある、ので貪欲はだめ。
- D we love abc
    - 概要
        - ?ABCを含む文字列からS_i,S_j,S_kがABCになるような組み合わせ
        - ?は全通り考える。
    - 解法
        - あるiまでに作れるAB(?を考慮する)の数を覚えておく
        - ?が出た場合、iまでに作れるABを3倍して、今までのAと?で作る、今までの?と?で作れる場合
        - C, ?が出たらans += AB, ?の場合は今までに作れるABCを三倍する必要もある    

### abc105

- B Cakes and Donuts
    - 4A + 7B = NとなるようなA,Bが存在するかどうか。
    - 解法自体は全探索するだけだが、
    - N>=21なら、N,N-7,N-14,N-21の中に4の倍数が存在するので、必ず存在する。面白い。
    
- C Base -2 Number
    - 与えられた数字を-2進数表示。
    - 結構時間かかった。。
    - また1 << iでlong longにしてなくてオーバーフローやってしまった。。
    - 自力解法
        - i番目のbitが1だったときに取りうる値の範囲を求めて計算した。
    - 想定解法
        - 2で割ったあまりに寄与するのは結局 0bit目のみ。
        - 同様に、4で割ったあまりに寄与するのは0,1bit目のみ。
        - つまり順々に決まる。
        - それはそう。。
        
- D Candy Distribution
    - ABC146E Rem of sumの簡単版
    - 問題
        - Al + .. + ArがMの倍数となるようなl,rの組み合わせ
    - 解法
        - Al + .. + Ar = S_r - S_l ≡ 0 (mod M)になっていればよい。
        - つまり、累積和をとったときに、あまりが一致していれば良い。
        - 左から累積和を計算しながら、過去に現れたあまりの数をカウントアップしていけばよい。



### abc106

- C	To Infinity
    - 5000兆日目のやつ。K番目までに1以外が現れたらそれ。現れなかったら1
    
- D	AtCoder Express 2
    - 概要
        - L,Rの区間を走る電車がある
        - 区間p,qに 走行区間が完全に含まれる電車の数はいくつか。
    - 解法
        - 結構むずかしいとおもうけど。。
        - 各電車のL, Rを二次元座標にマッピングする。
        - するとp, qに含まれる⇛二次元座標で長方形に含まれる電車の数。
        - 二次元累積和でとける。

### abc107

- B	Grid Compression
    - "#"がないところを消すやつ
    - "#"の数を数えちゃったけど、"#"が出たらtrueにして、あとでfalseを除けばよかった。
    
- C	Candles
    - ろうそくをK個灯すための最小移動距離。
    - 行って戻る系。
    - ばぐらせた。。
        - 負⇛正に変わるところのidxを計算してたが、正がない場合はidx=N。N-1ではない！！ 
    - 最小値系は、無駄なところを計算して問題ない。
        - （行って戻る必要があるのは明らかに連続するK個の領域の内部にスタートがある場合だが、そうでない場合をがんばって計算しないようにする必要はない。)
        -     REP(i, n-k+1) {
                  ans = min(ans, abs(x[i]) + abs(x[i+k-1] - x[i]));
                  ans = min(ans, abs(x[i+k-1]) + abs(x[i+k-1] - x[i]));
              }
        - こんなんでよい。        
- D	Median of Medians
    - 例の
    - 中央値 ⇛ x以上の値がceil(M/2)個あるようなxのなかで最大値
    - にぶたん && 累積和 && BITによる転倒数カウント



### abc108
C - Triangular Relationship
    - a+b, b+c, c+aがKの倍数となるようなa,b,cの組み合わせ
    - 2*a ≡ 0 (mod K)と出てくるので、Kの遇機で分岐
    - Kが奇数なら、a,b,cが全てKの倍数であることが必要十分
    - Kが偶数なら、a,b,cが全てKの倍数か、全てKでわって(K/2)あまること
    
D - All Your Paths are Different Lengths
    - パスの通り方で0~L-1までの全ての距離を作れるようなグラフの構築
    - 2べきと0の辺をつなげていくと、0~2^r-1までは作れる。
    - 重みは自由に設定できるので、残りは途中からNまで重みをつければ、X~X+2^t-1が作れるので、
    そんな漢字で適当につなげる。


### abc109
- D - Make Them Even 
    - 各マスにコインがあって、コインが偶数になるようにするやつ
    - 奇数だったら右に移動、を貪欲にやっていって良い。最後に最終列を縦に掃除。
    - 無駄に時間かかった。

### abc110
- D	Factorization
    - a1 x a2 x ... x an = M
    - となるようなa1...anの数列の通り。（一個でも違えば良い）
    - Mを素因数分解したとき、素因数ごとに独立に考えて良い。
    - p^dとすると、d個のpをn個のグループ割り振る重複組合せ通り。

### abc112
- D	Partition
    - a1+..+an = Mを満たすa1~anの最大公約数の最大値
    - Mの約数dで、M/dがnより大きければ作れるので、約数を大きい方から見るだけ

### abc113

- D - Number of Amidakuji
    - 概要
        - 1からはじめて、K番目に到達するようなあみだくじの数。
        - 棒を連続でつけたらだめ
    - 解法
        - dp[i][k] i番目の高さで、k番目にいる数
        - 次の遷移は、連続して棒をつけない組み合わせ。
        - 全部列挙すればいい。 1 << w個
        - もしくは、dp[j] = dp[j-1] + dp[j-2]        

### abc114
- C. 755
    - 桁DPっぽくみえるが、ありうる数字を列挙して、N以下なら足していく方式。
    - わからなかった。。。
    
- D. 756
    - これは簡単だった。
    - 約数が75個あるやつを数える。
    - 約数の数は、素因数分解したときの各素数の肩の数字+1の積なので、やるだけ。  


### abc116
- D. Various Sushi
    - 概要
        - 寿司iに、美味しさと種類が割り当てられてる
        - K個選んで、美味しさの合計 + 種類数^2　の最大値
    - 解法
        - f(x) = 種類xこ選んだときの美味しさの最大値
        - 貪欲に大きい方から選んだときの種類数xkの f(xk)は自明
        - f(xk+1) = f(xk) + A - B
        - A = 貪欲に選んだときに選ばなかった種類の寿司の最大値を足して、
        - B = 今選んでるうち、種類数が減らない（2個以上あるやつ）なかから最小値を引く
        - これ続けてf(x)埋めて f(x) + x*xの最大値             
   


### abc117
- D - XXOR
    - 概要
        - A1 ~ Anが与えられる
        - X = [0 ~ K]で、
        - f(x) = (X xor A1) + ... + (X xor An)の最大値
    - 解法
        - bitごとにみたときに、明らかに A1~Anで、0,1の多い方にしたほうがよい。
        - Kより大きくならないように桁DPするか、
        - どこのbitを x < kにするかの全探索

### abc118

- D - Match Matching 自力
    - 概要
        - ある数を表すマッチを構成するには、それぞれ決められた本数が必要
        - 作れる数と、マッチ本数が与えられる。
        - 全てのマッチをちょうど使い切る条件で、マッチで作る数字の最大値
    - 解法1
        - 明らかに、桁数が大きいほうが数が大きいので、使うマッチ本数が一番少ない数をいっぱい作るのが良い。
        - ちょうど作らないといけないので、最後調整が必要
        - 一番少ない本数をk、一番少ないやつで埋めたときのあまりをrとすると、
        - r, r+k, r+2k, をちょうど作れるやつのなかで一番おおきくなるやつを作る。
        - ちょうど作れるやつはDPで作っとく。
        - みすったとこ
            - ちょうど作れるやつを見つけたらbreakしてたけどだめだった。
            - 3=5, 8=7, 9=6で 8833と9999は 8833のほうが3をいっぱい作っているが、
            - 10+14=24で使う本数が同じかつ9999のほうが大きいので、breakせずもう少し見る必要がある

### abc119

- C - Synthetic Kadomatsu
    - 概要
        - 竹を何本か選び、A,B,Cの長さの三本にする
        - +1, -1, 合体の魔法を使える
        - 最小のMP
    - 解法
        - 全ての竹をA, B, C, 使わないのどれかに割り振ったら、その後は貪欲
        - 4^Nを全探索
    
- D - Lazy Faith
    - 概要
        - 神社と寺が数直線上にある
        - ある点が与えられて、神社と寺に訪れる最小移動距離
    - 解法   
        - 左側、右側の神社と寺をにぶたんで見つける
        - 右右、右行って左左、など色々試して最小見つける
### abc120

- D - Decayed Bridges
    - 概要
        - 無向グラフの辺を順に削除する
        - ある時点であるノートとノードが行き来できるか
    - 解法
        - 削除は難しいので、逆に構築していき、UnionFindで管理

### abc121

- D XOR World
    - 概要
        - f(A,B) を A,A+1,...,B の排他的論理和としたとき、f(A,B) を求めてください。
    - 解法
        - a xor b = cとすると b = a xor cなので
        - f(B) xor f(A-1)で良い。
        - 想定解
            - n xor n+1 = 1　(nは偶数)を使うと、
            - 1 ~ 6のxorは、1 xor 1 xor 1 xor 6になる
        - 自力解
            - bitごとにそのbitが立つのが何個あるか頑張って計算 
        
### abc122

- C - GeT AC
    - Sの[l, r)の'AC'の数。累積和のもちかた、ちょっと考える必要
    
- D - We Like AGC
    - 以下の長さNの文字列の数
        - AGCTしか含まない。
        - AGCを部分文字列として含まない。
        - 隣り合う文字をswapしても上記を満たさないといけない
    - dp[i][s1][s2][s3] : i番目まで見て, 先頭3文字が s1s2s3の数
    - 丁寧にAGCを含まない場合を処理していくだけ。

### abc123
- D - Cake 123
    - 概要
        - 3種類のケーキがあり、それぞれX,Y,Z個ある
        - X*Y*Zの組み合わせのうち大きいほうからK個列挙
        - X,Y,Z~1000, K~3000
    - 解法
        - X*Y*Zは当然間に合わない。
        - X*Yの組み合わせのうち、最終的に使われるのは、大きいほうからK個のみ。
        - つまりX*Yの上位K個とZでまた列挙して上位K個なので, O(K * Z)
        
       
     
### abc124
- D - Handstand
    - 概要
        - 0 or 1からなる文字列
        - [l,r)の0,1をすべてひっくり返すをK回行える、連続して1が続く長さを最大化
    - 解法
        - 010011100011
        - 連続する0をひっくり返す操作を、K箇所続けて行うのが一番良さそうなのがわかる
        - 連続する0, 1の数の配列のK個の連続部分和をN-K通り試す。
    - 工夫
        - 1100110011のように1が外側にあるとしたほうが扱いやすいので、
        端が0でも、1が0個あるという風にした。
   
### abc125
- C - GCD on Blackboard
    - 概要
        - A1 ~ An (Aは自然数)
        - どれか1つを自由に書き換えたあとのすべて数の最大公約数の最大値
    - 解法
        - 肝は gcd(A,B,C) = gcd(gcd(A,B), C) であること
        - 想定解
            - L[i], R[i]をずらしていく。L[i]は左からi番目までの最大公約数で、R[i]は右から。
            - 書き換える、というのをgcdの計算に入れない、という発想
        - 自分解
            - セグ木で、ノードのマージをgcdにした。
            - gcd(a,0) = aなので、単位元が0になって割ときれいに解けた。
            - 各Nに対して、0にセット->根クエリ->もとの値セットで最大値探索
            
- D - Flipping Signs
    - 概要
        - A1 ~ An (Ai は負もある)
        - 連続する2つに-1をかける操作を好きなだけして、和を最大化する
    - 解法
        - -10, 5, -4
        - 負の数が偶数なら、結局全部正にできて、奇数なら1個だけ負になるようにできる
        - 奇数のとき sum(A) - 2 * min(abs(A))でOK

### abc126
- D - Even Relation
    - 概要
        - 重み付き木を白黒に塗り分けて、
        - 同じ色の距離が偶数になるように
    - 解法
        - uとvの距離は、du + dv - 2 * d_lca
        - ３項は偶数なので、du + dvが偶数 -> 適当に根決めて距離が偶数、奇数で塗り分ければ良い。        

- E - 1 or 2
    - 概要
        - A1 ~ An (A=0,1)
        - Xq, Yq番目の和がわかる、という情報がQ個
        - 何枚のカードをめくればすべての情報がわかるか
    - 解法
        - 1,2の和がわかって、2,3の和がわかってれば、1,2,3のどれかがわかれば他がわかる
        - つまりUnionFindで結合していって、素集合の数が答え

- F - XOR Matching
    - 概要
        - 0 ~ 2^Mの数を2こずつ含む数列で、
        - 同じ値の間に含まれる数のxorがすべてKとなるような数列の構築
        - ai == ajのとき、 ai xor ai+1 xor ... xor aj = K
    - 解法
        - a xor a = 0
        - a,b,c,d,e,K,e,d,c,b,a,K
        - ってやれば、a-a,b-b,...,e-eについて間のxorは打ち消しまくってKが残る
        - K~Kの間はa,b,c,d,e,K,Kのxorだが、0~2^M-1のすべてのxor(=X)とKのxor
        - Xは各bit見たときちょうど0と1が2^(M-1)回出るはずなので、必ず0
        - つまり、全ての数に対して間のxorがKになる
        
### abc127

- E - Cell Distance
    - 概要
        - NxMのマス目にK箇所にコマをおいたときの、全てのコマ間距離の総和の、全ての置き方に対する和
    - 解法
        - ある1マスxに関連する距離の和をまず考える
        - xとaにコマが置かれるのは、その2マスを除いてK-2コマ分選ぶので、N*M-2 C k-2
        - これはxから見て、全てのマスa=1~NMに対して成り立つので、
        - N*M-2 C k-2 * （xから全マスへのマンハッタン距離の和)
        - 実は、全てのマスに対してこれは成り立つので、
        - N*M-2 C k-2 * Σ_x_N（xから全マスへのマンハッタン距離の和) / 2
        - が答え
        
- F - Absolute Minima
    - aのmedianがmin_xとなる。
    - 最小値を取り出すpriority_queueと最大値を取り出すpriority_queueをごちゃごちゃする。

### abc128
- E - Roadwork
    - 概要
        - N個工事があり、Si ~ Ti の時刻, 座標Xiを通行止めにする
        - M人が時刻D[i]から時速1で移動し、通行止めにあたったら止まる。止まる距離を答える
    - 解法
        - S-X, T-Xにしたほうが扱いやすい
        - Sでソートすると、D[i]を考えるときに、すでに始まってる工事を取り出せる
        - すでに始まってる工事を、xが近い順に取り出せるpriority_queueにつっこんでおく。
        - すでに始まってる工事の中で、一番近い工事を取り出し、まだ終わってなければそこで終了。
        もうTよりD[i]が大きく、終わっていたら、popして次に近い工事を取り出す。
        
- F - Frog Jump
    - 概要
        - A進む->B戻る->A進む->B戻る　を繰り返して、蓮にある点数を取得、すでに訪れたところに行ってはいけない。
        - 得点の最大化
    - 解法
        - A, A-B, 2A-B, 2A-2B -> A-BをCとすると、
        - A, C, A+C, 2C, A+2C, 3C, ... , A+kC　となりキレイ。
        - A + kC = N − 1 なので、Cとkで全探索できる。
        - さらに、k, Cのときの得点をf(k, C)とすると、
        - f(k+1, C) = f(k, C) + S_(N-1-kC) + S_kC なので, f(k, C)の計算はO(1)
        - 調和級数 Σ_k n/k ~ O(nlogn)なので、k, Cの全探索は O(nlogn)なので間に合う
              
### abc129
- E - Sum Equals Xor
    - 概要
        - a + b <= L
        - a + b = a xor b
        - となるa,bの組み合わせの数
    - 解法
        - i番目のbitで、Lより真に小さいか、否かを持ちながら上位bitから桁dp
        - ab=00, 01, 10が選べる。

- F  Takahashi's Basics in Education and Learning
    - 数列の遷移を行列の掛け算で表現することで、数列のN番目の要素をlogNで求める

### abc130
- E - Common Subsequences
    - レーベンシュタイン距離的な感じ。
    
- F - Minimum Bounding Box
    - xmaxに着目
    - xmaxになりうる点の候補は、L, R, U, Dの方向を向いているうち一番xが大きいもの (xmax_candidate)
    - t秒立った時点で、 xmax = max(L_xmax - t, R_xmax + t, U_xmax, D_xmax)
    - xmaxは下に凸の折れ線となることがわかる ＼_／ こんな感じ
    - xmax, xmin, ymax, yminそれぞれ同じこと。
    - ここで、面積が最小となるのは、xmax, xmin, ymax, yminの極小点（折れ線の頂点）のどれかだとわかる。
    - この極小点はせいぜい12個しかないため、全部試せばOk

### abc131
- E - Friendship
    - 概要
        - N頂点グラフで、距離が2となるような頂点i,jの組がちょうどK個になるものの構築
    - 解法   
        - うにをつくると、N-1C2がすべて距離2になる。
        - うにの各頂点間を１本つなぐと、距離2の組み合わせが1つ減る。
        - N-1C2 - K 本つなげばOK
        
- F - Must Be Rectangular!
    - 頂点間でx, yのどちらかが一致していたら辺が張られるようなグラフを考える。
    - 求める答えは、このグラフ上での各連結成分内の (xの値の種類 * yの値の種類 - 頂点の数)の和

### abc132
- D - Blue and Red Balls
    - 赤、青のボールの組み合わせ

- E - Hopscotch Addict
    - けんけんぱでダイクストラ
    - 各頂点に0,1,2の状態をもたせ、接続している頂点で自分の状態+1に遷移できるダイクストラ 
    
- F - Small Products
    - 数列の末尾がaだったとき、次の要素の取りうる範囲は 1 ~ floor(n/a)
    - 列挙してみると、n/b+1 ~ n/b では、次の要素の取りうる範囲が1 ~ bで変化しない
    - bの取りうる値は、2*√n 通り 。
    - いい感じにまとめてあげればO(√n・K)で解ける
    
### abc133
- D - Rain Flows into Dams
    - 数式建てると一周して方程式になるので、一意に決まる

- E - Virus Tree 2
    - 考えるだけっちゃ考えるだけ
    
- F - Colorful Tree   
    - 概要
        - 	辺の色と重みがついていて、根からある頂点までに現れる、特定の色の辺の数、重みの和を計算する必要がある
        - 	色と頂点を配列で持つと、空間計算量が O(N^2)になる。
    - 解法1
        - 	オイラーツアーを色ごとにリストで管理して空間計算量をO(N)に落とす。
        - 	元のオイラーツアーでの出現箇所のidxと重みのタプルを保持することで、根から頂点までの各色の重みを二分探索で計算 O(QlogN)
    - 解法2
        - クエリを先読みして、DFSしながら訪問中に頂点分の各色の重みを保持し、解答に必要な部分の計算をその時点で行う O(N+Q)

### ABC134

- D - Preparing boxes
    - 概要
        - a1 ~ aNが与えられる
        - 1~Nの任意の整数iの倍数が書かれた箱に入っているボールの個数の和を 2 で割った余りが ai である
        - これを満たすb1~N  bi=(0 or 1)があるかどうか
    - 解法
        - 後ろから貪欲に0か1を決めていく。

- E - Sequence Decomposing
    - 概要
        - AiとAjが同じ色で塗られているならAi < Aj
        - を満たすように色を塗るときの最小の色の数
    - 解法
        - Longest Decreasing Sequenceを解くだけ。
        - 負にしてLIS貼れば終わり。
                       
- F - Permutation Oddness
    - 箱根駅伝DP と呼ばれるもの
    - ペアリングによって値が決まるとき、今までにペアリングを保留している要素の数、を管理することできれいにDPが決まる。


### ABC137

- D: Summer Vacation
    - M日後の報酬が最大となるA日後にB円もらえるバイトのうけかた 
    - なんか結構時間くった
    - 後ろから受けられるバイトの候補を増やしながら候補の中で最大報酬をうける
    - 候補を増やすpriority queueと、候補の最大のためのpriority queue
    
- E - Coins Respawn
    - 1分かかる辺を、辺のコインを拾いながら目的地に向かい、T分 * P枚のペナルティを払ってゲーム終了
    - コインの枚数をc - pとしてベルマンフォード
    - 目的に向かわない負閉路をNGにしてしまってみすってた
    - あと勝手に同じu, vの辺のコインを足してしまってたけど、別の辺がある扱いだった。。
    
- F - Polynomial Construction
    - f(x) = Σ_0~p-1 b_i * x^i　として、
    - f(j) == a_j (j=0~p-1)を満たすb_iを求める。a_j = [0, 1]
    - 想定解はかなりきつい
        - フェルマーの小定理からa^p-1≡1 より、
        - g(x, j) = 1 - (x - j)^p-1とすると、 x=jでg(x, j)=1, x≠jでg(x, j)=0
        - つまりa_jが1となるjに対してg(x,j)をf(x)にたしていくと、条件を満たす多項式になる
    - ラグランジュ補間の発想は便利そう
        - (x_1, y_1), (x_2, y_2),...,(x_n,y_n)を通るy=f(x)を因数定理でいい感じに表現
        - 詳細 https://suikaba.hatenablog.com/entry/2019/08/11/021048
        - (x-0)*(x-1)*...*(x-(p-1))を求めたり式の筆算するところはちょっと大変


### abc141

### abc142
- E - Get Everything
    - bitDP

- F - Pure
    - mada
    
    
### ABC143
- E. Travel by Car
    - 概要
        - 重みc付き無向グラフの距離
        - 燃料Lが与えられ、移動するとL-cとなり、足りない場合はLまで補給
        - 補給回数の最小値
    - 解法
        - 補給回数と残燃料のペアをコストにしてダイクストラを全ノードで行う
    - 想定解
        - わーシャルフロイドで全点最短距離求める。
        - 距離がL以下のノード間に1の辺を貼るグラフを構築し、もっかいわーシャルフロイド
        

### ABC144

- E. Gluttony
    - 概要
        - コストF1~Fnと、コストA1~Anでペアを作る
        - ペアの中の fi * Aiの最大値を最小化
        - F1~FnはK個まで減らすことができる
    - 解法
        - 解のにぶたん

- F. Fork in the Road
    - 概要
        - DAGで、各ノードでランダムに辺を選んでゴールまで行くとして、
        - スタートからゴールまでの距離の期待値をEとする
        - DAGの辺をどれか切って、Eを最小化する
    - 解法
        - 後ろからEを計算すると、O(M)でEは計算可能
        - 切る辺は、明らかに辺のうちEが最も悪いノードへの辺 -> n本しかない
        - O(N*M)でいける 

### ABC146

- E: Rem of Sum is Num
    - 概要
        - 長さNの配列Aからの部分列で、要素の和のmod Kと、要素の数が一致する物の数
    - 解法
        - i,jの組み合わせの、累積和系
        - sum = i - jとなっていれば良い
        - 累積和をTiとすると、Ti - Tj = i - j
        - 今まで出てきた中で、Ti - i = Tj - jとなるjを数えれば良い
        - ちょっとめんどかったのが、Tiはmod Kだが、要素の数の方はmodじゃないので、
        i-K<j<iとなるjのものだけ覚える必要があるので、i-Kをどんどんmapから消していく


### ABC148

- E - Double Factorial
    - 概要
        - f(n) = n f(n-2) , f(0)=f(1)=f(2)=1
        - f(N)は、0が何個続くか
    - 解法
        - なんかすごい時間かかった
        - 奇数のとき、2の倍数が出てこないので、一個もつかない
        - 偶数のとき、逆に2はめっちゃ出てくるので、5が何個出てくるか、
        - N N-2 ... 10 8 6 4 2 の積になるが、考えづらいので2で割ると、
        - N/2 N/2-1 ... 5 4 3 2 1となる。
        - 結局、N/2までで、5の倍数、5^2の倍数、...を数えれば良い

- F: Playing tag on tree
    - 概要
        - 木で点u, vがあって、点uはvから逃げる、点vは点uを追う
        - uから先に、交互に1ずつ隣接辺を移動する
        - u, vが同じ点になったら終了で、そのときのvの移動距離
    - 解法
        - 頂点をvにするとわかりやすい
        - uが頑張って逃げても、uは確実に追い詰めることがわかる。
        - また、uの逃げ方によらず、vは無駄な移動をする必要がないので終了状態での頂点までの距離が、vの移動距離になる
        - u側の最適な終了状態は、葉の1個手前でつかまることだとわかる
            - 一個ずつ動かすと、葉では絶対終わらないことがわかる
        - つまり、vより先にたどり着ける葉のうち、最も遠いものを選べばok
            - vより先にたどり着ける、を無駄になるLCAしたが、
            - 2回dfsしてu, vそれぞれからの距離を求めればよかった。

### ABC149

- D - Prediction and Restriction
    - 概要
        - じゃんけんで出す手の順が確定している相手
        - それぞれの手によって、勝ったときにもらえるスコアが与えられる
        - 負け、あいこはともに0点
        - ちょうどK回前に出した手は出すことができない
    - 解法
        - mod Kごとに独立だとわかるので、それぞれ考える
        - ぐーを出すことによって、次に出すことができなくなるのはぐーで、
          そのときにぐーを出せたとしても結局もらえる点数は一緒
        - ただ、ぐーを出せないからといって、適当にパーをだして、その次に勝てるはずのパーが出せないのはだめ。
        - 結局、出せたら勝ちを出す。出せなかったら、次に影響がでない手を出す。
        - 発想としてabc166Fににてるかも？
        
- E - Handshake
    - 概要
        - N個の数列A
        - Aから重複を許してペアをM個つくって、Ai+Ajを最大化
            - Ai, Aj != Aj, Ai        
        - N=1e5, M<N^2
    - 解法
        - 当然だが、できるだけ大きい方からM個選びたい
        - Mが大きいので数えられない
        - Xより大きいペアがM個以上ある、ようなXの最大値をにぶたんでもとめる
            - Xより大きいペアが何個あるか、は配列をソートしておきlower_boundしてnlognで求まる
        - 求まったXのときの合計を出せば良い
            - 同じ和が複数個そんざいすることがあるので最大のXのとき、Xより大きいペアがM個より多いことがある
            - X+1だと、M個にならないのはにぶたんから確定なので、Mを超えた分は全部Xのはずなので、その分引く。 

### ABC150

- D: SemiCommonMultiple
    - 概要
        - 遇数列akがあり
        - すべてのkに対し、X = ak * (p + 0.5) となる整数pが存在するようなXの数
     - 解法
        - bk = ak/2
        - X = bk * (2p + 1)
        - bkの最小公倍数をlcmとすると、X = lcm * 奇数が条件を満たす
        - ただ、lcm/bkが偶数となるものがあると、(lcm/bk) = 2p+1 が成り立たない。
        - そうでないなら、M以下のlcmの奇数の倍数の数
        
- E: Change a Little Bit
    - 概要
        - N個の0,1からなる数列S, T
        - f(S,T) : S, Tを操作によって等しくするための最小のコスト
            - iを変えるには、その時点で異なる箇所の数をDとすると C[i] * Dコストがかかる
        - すべてのS,T (2^N * 2^N) に対する f(S,T)の総和 
    - 解法
        - とりあえずSはすべて0として、Tの1の部分を1にするとして、あとで2^Nかけてよい
        - 明らかに、大きい数をあとにスイッチさせるほうが良い。
        - こういう問題は、とりあえず各項目が寄与する数を数えるのが良い
        - 小さい方からi番目が, D=jとなる状態で加算される数 g(i, j)
            - g(i, j) = N-i C j-1 * 2^(i-1)
            - iより大きい方(N-i)からj-1箇所, T=1を選択して、
            - iより小さい方はT=0,1どちらでもよいので2べき
        - これで O(N^2)になった
        - -> jに対するg(i, j)はOIESで調べたら出てきた
            - 解説では、考えたらこうなるから、って感じだったけどよくわからず TODO


### ABC151

- D	Maze Master
    - 概要
        - グリッド上の迷路の、一番遠い２点
    - 解法
        - わーシャルフロイド or BFS全通りHW回
        
- E	Max-Min Sums
    - 概要
        - 集合Xに対して、f(X) = max_X - min_Xとする
        - 配列AからK個選んだ部分集合すべてのf(X)の総和
    - 解法
        - 要素xがmax, minとなる回数を数える
        - 配列をソートしておき、
            - i番目が最小となるのは、N-i個からK-1か選ぶ
            - i番目が最大となるのは、i個からK-1か選ぶ
        
- F	Enclose All
    - 概要
        - N個の点をすべて含む円の最小半径
    - 解法
        - 3点選んで円を決めて、含むかどうか全部見る
        - 実はこれだけだとだめで、2点拾って最小の半径でやるほうがいいときがある
            - 2点が遠く離れててまんなかに密集してたら、3点を選ぶより小さい
    - 解説
        - 逆に、N個の点を中心とする、半径Rの円が共通部分を持つなら、
        - その部分のどこかの点を中心とする半径Rの円は、すべての円を含む
        - また、その共通部分は、N円のうち2円の交点を含むはず。
        - Rをにぶたんで広げながら、NC2の交点をすべて列挙して、すべての点からR以下だったらOK



### ABC155


- D - Pairs
    - 概要
        - 配列Aのペアの積のうち、小さい方からK番目
    - 解法
        - にぶたんで, xより小さい要素がK個あるようなxの最小値
        - 超典型だが、Aに負があるせいで、めっちゃめんどかった
        - 小さい要素のカウントを、正負で分けて、符号に気をつけてlower_boundする必要があった
    - 振り返り
        - lower_boundじゃなくて、普通にwhile loopでやったほうが確実だったかも
        - 最後、にぶたんが出てきた結果のxに近い積を求めようとしてしまったが、
            - 最終状態のxは境界なので絶対積のなかのどれか、
            - ばか


- E - Payment
    - 概要
        - 10^0, 10^1, ... 10^100000 の紙幣があって、
        - N円を払うときに、支払いとおつりでやりとりされる紙幣の数を最小化
    - 解法
        - どこで桁を借りるか、払い切るか、を考えてくと簡単には決まらないとわかる
        - dp[i][0] : i番目まで見て、貸し借りなしの状態
        - dp[i][1] : i番目まで見て、1多い状態
        - って感じのdpで解ける
        - i番目に貸し借りなしなのは、
            - i-1で貸し借りなしから、iでも払い切る
            - i-1で1多く払ってるのを、ここで解消する
        - i番目に貸し借り１なのは、
            - i-1で貸し借りなしから、1多く払う 
                - 149だったときに2桁目で5まで払う
            - i-1で1多く払ってる状態から、保留する 
                - 1489で、1500払った状態の、3桁目の8で、1しかもらわない)

### ABC158

- D	String Formation
    - 概要
        - 文字列の先頭にcを足す
        - 文字列の末尾にcを足す
        - 文字列を反転
        - の操作を繰り返したあとの文字列
    - 解法
        - 反転すると重い
        - 反転の状態を覚えておけば、先頭か末尾に足す操作だけで最後まで行ける
            - 反転してる状態で先頭だったら、末尾に足せば良い
        - dequeで処理すればOK
        
- E	Divisible Substring
    - 概要
        - abc164Dとほぼ同じ
        - 2019じゃなくて、素数Pが与えられる
    - 解法    
        - 素数PとしてP=2, 5のとき、10倍してくと全部modが0になってしまうので使えない
            - コイツラは末尾の数字だけで幸い決まるので、特殊処理する
        - あとは同じ
            - 10^dしてmodとって累積和をmapで処理 
         
### ABC159

- F - Knapsack for All Segments
    - 概要
        - Aの部分列のうち、区間[L,R]を制限したとき、
        - A[L...R]の部分列で和がSとできるような組み合わせの総和
        - 部分列全てに対してナップサックというイメージ
    - 公式解説
        - Aの中で、和がAx1 + Ax2 + ... + Axk = Sとなるような x1,..xkがあったとして、
        - L,x1,...,xk,Rの組み合わせを考えるのと同じ
            - この発送は大事
        - dp[i][j][t] (t <= 3))
            - i番目までみて、和がjとなり、(Lをきめてない, Lだけ決めてる, LRどっちも決めてる）
            - 耳DP？というらしい
                - https://drken1215.hatenablog.com/entry/2020/03/22/224200
                - t=0は結局、j=0のときに1
    - kmjp
        - https://kmjp.hatenablog.jp/entry/2020/03/22/0930
        - 本質は同じだが、スマート
        - 添字iが一番左になってSを作れるやつは、Lを0..iまで取れるので、
        - dp[i][j]のj=0から配るときはi倍すれば良い。
        - 発想としては、
            - 普通のDPでL=0, Rが0からiまでの部分列でのSは、毎ループ中に足してけばとれる。
            - Lを動かしたときのやつを考えたいが、各iが左になるときにLはそれ以下取れるよねって感じ。
        

### ABC160

- F - Distributing Integers
    - 概要
        - 木があって、頂点kに、1を割り当てる
        - 整数が割り当てられた頂点の隣接ノードに次の整数を割り当てる
        - k=1~Nに対して、整数の割り当て方の列挙
    - 解法
        - 発想として、ノードの頂点番号の順列の組み合わせだと考えたほうがやりやすい
        - k=1 (根) の時を考える
            - 根から子が2つで、/\ こんな感じにそこから分岐がない場合を考える
                - それぞれの頂点が1,2,3 - 4,5,6だったとする
                - 1,2,3の順番は変えられないが、4,5,6との位置は自由に変えられる
                    - 123456, 4 123 56 など   
                - これは、N+M C N 通りの並べかたがある。
                    - 順番が決まってるのでn+m個のマスからn個選んで左側を選ぶという感じ
            - 一般的な木の場合
                - 普通は子のなかに分岐があるので、123, 132など左側にいくつ並びの可能性がある
                - ただ、左と右のマージ方法, 左の並び方、右の並び方はすべて独立
                - つまり、部分木のサイズがn,m　それぞれの並べ方がCn, Cm だとすると、
                    - Cn * Cm * n+m C nが、根から見た並べ方の総数
                - これは、上から再帰でやってけば根から並べ方をすべて列挙できる                     
            - これで、いったんすべてのkに対して根としてこれをやればO(N^2)
            
        - k!=1の時をどうするか
            - 制約的にN^2はだめなので、高速化しないといけない。
            - ある頂点vに着目すると、
                - こいつの並べ方は、
                - vの部分木の並べ方と、
                - 根方向の頂点pの並べ方からvの部分木による寄与を覗いた分
                - をマージしたものだとわかる
            - マージは単純な掛け算なので、割り算をすることで寄与を除くことができる！
            - なので、もう一回根から順番に、全頂点に対して、親方向の寄与をマージしていくことで解ける
            
    - 解説
        - 全方位木DPでかんたん、みたいに書いてあってくそ不親切
        - いつか調べる TODO                            
                              
### ABC161

- E - Yutori
    - 概要
        - N日感の中でK日働く
        - 働いたあとC日間働かない
        - 配列でo指定された日にしか働けない
        - 絶対働かないといけない日はどこか
    - 解法
        - k日目を使わなかったとして、成立するかどうかを考えたい
        - おなじみのDPを前後からやる方法でいったんそれっぽいのができる
        - k番目を使わなかったとして、k-1, k+1のそれぞれの最適でKを超えたらいらなそう
        - が、k-1, k+1がC空いてないとそれぞれを選べないのでだめっぽい？？
            - と考えてしまったが、けんちょんのブログでこれが違うと書いてある
            - https://drken1215.hatenablog.com/entry/2020/04/05/163400
        - 少なくとも、i, i+CでKを超えたらその間はいらない。
        - iをNまでループして、C回ループするとO(N^2)なので、imos法で最後にいらないやつを計算
        - ⇛　合ってると思うけど、実装が違うのかWA...
    - 答え
        - k番目を使わずに、左右を見てKを超えてもその選び方は使えないんじゃないか、と見えるが、
            - その場合、k番目を使ってもどうせ選べないから関係ないとわかる
                - 問題として、成立する選び方があることは保証されているので、いらないかどうかだけを論じれば良い。
                - 考えるのは、Kを超えているが、kを使わないといけない時があるかどうか
            - ooo の真ん中をkとしたとき、C=2でk-1, k+1の和がKだったとして、
            - k-1, k+1を使う場合よりも、真ん中を使ったほうがよくはならないので、いらんとわかる
    
    - 答え2
        - 「x回目に働く日は L[x] 日目以降」という配列 L
            - 前から貪欲に働く
        - 「x回目に働く日は R[x] 日目以前」という配列 R
            - 後ろから貪欲に働く。前から見たら一番余裕を持つ働き方 
        - i日目に必ず働くのは、L[x] = R[x] = i となる x が存在するとき

- F:Division or Substraction
    - 概要
        - N以下のKで、
        - NがKで割れるなら割って、そうでなければKを引く、
        - という操作をしたときに1になるようなKの数
    - 解法
        - NがKで割れない状態のときに、N-KがKで割れることはない。
        - N = (aK + 1) * K^b  となれば良い。
        - b=0のとき、N - 1で割り切れるKすべて
        - b>0のとき、Nの約数で、かつ割り切ったあとにN-1で割り切れれば良い。
    - やらかし
        - long longのオーバーフローに気づかなくてしばらくつらかった。
        
### ABC162

- D	RGB Triplets
    - 概要
        - r, g, bからなる文字列
        - 要素がrgbとなるようなi, j, kのとり方の組み合わせ
        - ただし、i, j, kが等間隔になるものを除く
    - 解法
        - i, jを固定して、k<i,jの数を数えて、i,jと等間隔なkがrgbだったら引いた
    - 答え
        - 全部の組み合わせがrgb個だから、等間隔を引いたほうが絶対早い。。ばか

- E	Sum of gcd of Tuples (Hard)
    - 概要
        - 1~KのどれかからなるN個の数列 K^Nの全てについてのgcd()の和
    - 解法
        - gcdがnになるようなやつが何個あるかを数える
        - gcdがnとなる数は、(K/n)^Nが基本で、nの倍数が公約数になるやつを引けば良い
        - 大きい方から求めていけば、引くための数が求まっている状態になるのでOK

- F	Select Half
    - 概要
        - Nこの要素の配列Aから、N/2個、隣り合わせのものからは取らないように選ぶ
        - その総和の最大値
    - 考察
        - 全部列挙できるかと思ってがんばったが、実は N*(N+1)/2個あるので無理
    - 解法
        - DPでいける。ちょっとめずらしい
        - dp[i][j] = i個見て、(i+1)/2-j選んでいる状態の総和の最大値
            - iによって、何個選んでいるかを変える
            - 何個持っているかを持とうとすると j < NとなってオーダーがO(N^2)になる
            - i個まで見たとき、残りのn-i個からは最高でも (n-i+1)/2個しか選べない。
            - 計算すると、たかだかj=2までしかスキップできない。
        - うまくやる方法わからず、すごいださい遷移になったが、他の人解法見るとめっちゃ短い。謎。 TODO
        - ダイクストラっぽいのでも溶けるらしい
            - https://atcoder.jp/contests/abc162/submissions/11810863

### ABC163

- D - Sum of Large Numbers
    - 概要
        - 10^100, ... 10^100 + N までのN+1個の数
        - こっから、K個以上選んだときの和として、ありうるものの個数
    - 解法
        - i個選んだとき、一番小さい組み合わせの和 ~ 一番大きい組み合わせの和まで全部作れるので、
        - それをK~N+1まで足すだけ
        
- E - Active Infants
    - 概要
        - 配列を並び替えて、新旧の位置の差 |xi - yi| x Aiの最大化
        - 順列選ぶ
    - 考察
        - 一番大きいやつは、左端か右端にもってくのがいいとわかる
        - また、それぞれの要素を左側にもってくか、右側にもってくかまず決めたら、左側、右側はそれぞれ端に向かって昇順になるのがよいとわかる
    - 解法（答え見た）
        - dp[l][r]: 大きい方からl+r個見て、l個は左、r個右のときの最適な合計
        - まずAを大きい順にソートして、1個ずつ左に置く場合と右に置く場合を計算する
        - k個目を見てて、左に置く場合は、左にl個おいてあったら、l+1個目に置くのが最適。vice versa.
        - 新しいDPの感じだった。
        
### ABC164

- D. Multiple of 2019	
    - 概要
        - 文字列のSijを数字としたときに, 2019の倍数となるようなi,jの組み合わせの数
    - 解法
        - 各桁の2019のmodを先に計算しておく. 
            - 122220だったら、1文字目は100000 mod 2019みたいな
        - すると、abc146eと同じような問題になる
        - modの累積和を持って、i < jで Ti = Tjとなる数を数えてけばいい
        
- E. Two Currencies 
    - 概要
        - ノード間の移動に、金額aと時間bがかかる。
        - 立ち止まって、金額cをgetするが時間dかかる選択肢もある
        - 各ノードへの最短時間
    - 解法
        - N, Mが小さいのでちょっと工夫したダイクストラでいける
        - あと、金額aの上限が50なので、必要なお金の最大値がせいぜい2500に抑えられる
        - ノードと金額を状態としてダイクストラすればOK
    - やらかし
        - 各状態の最適値をmapで持ったらやっぱ遅かった。。
            - 無駄な枝刈りがいっぱい必要だった
        - INF=10^12にしたら足りなくてずっと通らなかった。。。
        
        
### ABC165
- C	Many Requirements
    - nHrの列挙

- D	Floor Function
    - 概要
        - (Ax)/B - A(x/B)の最大値 (x <= N))
    - 解法
        - x = Bp + rと置くと、(Ar)/Bが残る
        - 明らかにrは大きいほうが良いので、B-1かNの大きい方のとき最大 
        
- E	Rotation Matching
    - 概要
        - アリーナに対戦ペアのidxを割り当てる
        - 出場者のidxは、毎ラウンドごとにインクリメントされる
        - アリーナにどうidxを割り当てると、かぶらずに全対戦できるか
        - N人、Nラウンド、Mアリーナ
   - 解法
        - 明らかに、差が1, 2, 3, ... になるように割り当てれば、いい感じに回る
            - 対戦相手が自分より1, 2, 3つ先のidxの人と戦う、ってすれば良いから
        - Nが奇数のときは、それだけ。
        - Nが偶数のとき、例えばN=6だと、差が3だと1-4, 4-1ができちゃう。
            - Nが偶数のとき、全員と対戦できる必要がない成約なので、1-4は戦わなくていい
            - 結局N-1しちゃえば良い
        - 差が1,3,5..., 2,4,6... になるよう上手に選べばOK
    - 振り返り
        - E, Fの解かれている人数が同じで、Fができそうだったのでもはや考えてなかった。解けたはず。。 

- F	LIS on Tree
    - 概要
        - 木上で、頂点ごとに数が割り当てられる
        - 根から各頂点までのパス上の数列の、LISの長さをそれぞれ求める
    - 解法
        - HL分解して、lightに分岐するときはlisをコピーすればいいやの方針
            - lightへの分岐はlogN回のはずだから
        - が、なんかだめだった。なぜかわからない。TODO
    - 答え
        - 考えてみれば当たり前で、1回の更新で変化するのは、1箇所なので、それをmemoっておけば   
        木を遡りながらlisをもとに戻すことができる。
        - 巻き戻しのテクニックというらしい。
        
    - 振り返り
        - lisをINFで初期化してなくて、{1,0,0,0}という配列でlower_boundしてエラー
            - 多次元配列だから怒られてるのだとばかり思って、10分以上これで悩んでた。。。。
        - 拾ってきたHL分解の実装が、構築で再帰してて、最悪ケースだとスタックオーバーフローしてた。
            - あやしいときは再帰危ない
            - 使ってないやつも落ちてたからそれ使うようにする
        
### ABC166

- D	I hate Factorization
    - 概要
        - X < 10^9 が与えられる 
        - A^5 - B^5 = X となる整数A,B
    - 解法
        - XはA-Bで割り切れるので、約数kとして、b = a-kとして、
        - (a+1)^5 - a^5を考えると、a^4が出てくるので10^9となるのはa < 1000で十分だとわかる
        - ので、aを適当にループさせた
    - 解説
        - 約数取らなくてもa, bどっちも適当ループでOK
        
- E	This Message Will Self-Destruct in 5s
    - 概要
        - 配列Aがあり、Ai + Aj = |i - j| となるi, jの組み合わせ
    - 解法    
        - いったんAi-iとしておいて、-Aj+jを探しに行く
        - なんか頭こんがらがってすごい実装遅れた
    - 解説
        - Li = i + A[i], R[j] = j - A[j]
        - こっちのほうが良いわ
        
- F	Three Variables Game
    - 概要
        - 数A, B, Cが与えられる
        - AB, BC, ACのどれかのクエリが与えられる
        - ABだったら、A,Bのどちらかを1足して、どちらかを1引く
        - 負にならないような選び方
    - 解法
        - A+B+Cの和は常に同じ
        - 選ばれた数が、
            - 0 0 ならアウト
            - 0 a なら、1 a-1にするしかない
        - 1 1 0のとき、2 0 0にして、その次でBCを選ばれたらだめ
            - このときだけ、直後を見てそうならないほうを選ぶ
        - それ以外は、適当にやってけばよい
    - 振り返り
        - 1 1 0のとき、次だけみればいいかもなーって思いながら、ちゃんと
        考えずにDPするかってして時間溶かしてしまった。。。

### ABC167

- D	Teleporter
    - 概要
        - 
    - 解法
        - 痴漢
- E	Colorful Blocks
    - 概要
    - 解法
- F	Bracket Sequencing
    - 概要
    - 解法

