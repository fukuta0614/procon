


## Atcoder Beginner Contest Like

### HHKB プログラミングコンテスト 2020
    
- D	Squares
    - 概要
        - 辺Nの正方形に、辺A、辺Bの正方形を入れる
        - 辺A, 辺Bの正方形が重ならないように配置する方法
    - 解法
        - 答えをansとする
        - 重ならない配置はむずそうなので、重なる配置X1を考える
            - ans = 全体 - X1
            - 全体 = ((N-A+1)*(N-B+1))^2
        - 縦横のどっちかが重なってればよく、縦で重なる配置X2 x 横で重なる配置X2
            - X1 = X2 ^ 2
        - 2次元から、1次元で考えていいようになる。
        - この場合、重なる配置X2より重ならない配置X3のほうがかんたん
            - X2 = (N-A+1)*(N-B+1) - X3
        - (空白)(青)(空白)(赤)(空白)となっていれば重ならない
        - 空白マスの総和はs = N-A-B
        - 重ならない配置X3 = 2 * nCk(s+2, 2)
            - 赤、青のどっちが左かで2通り
            - 空白マスと赤青の配置の組み合わせ
        
- E	Lamps
    - 概要
        - HxWのマス目に壁と道がある
        - 道に電球を配置することができる。
        - 電球を配置すると、上下左右、壁にぶつかるまでの道を照らす
        - 道の数をkとして、2^k通りの電球の配置それぞれで照らされる道、の総数
    - 解法
        - 各マスを照らすことのできるマスの数cntをそれぞれのマスについて数える
        - 2^kのうち、あるマスが照らされない回数は、2^(k-cnt)
        - cntは、愚直にやるとO(HxWx(H+W))かかるので、縦、横それぞれ、連続する道を管理しながらcntを足していけばよい。
        
- F Random Max
    - 概要
    - 解法

### エイシング プログラミング コンテスト 2020
    
- C	XYZ Triplets
    - 概要
        - f(n)
            - x,y,z >= 1
            - x^2 + y^2 + z^2 + xy + yz + zx = n
            - となるようなx,y,zの数
        - f(1),f(2),...,f(n)をすべて求める
        - n <= 1e4
    - 解法
        - x,y,z <= sqrt(n)なので、
        - x,y全探索して、2次方程式の解からz求めて整数かつ1以上だったら足す
        - 一応 1e8くらい
    - 想定解
        - x,y,z全探索して1~nだったら足しておけば良い
        - これ思いつかなかったの結構ショックだな
        
- D	Anything Goes to Zero
    - 概要
        - f(n)
            - nをpopcount(n)で割ったあまりする。
            - を繰り返してn=0になる回数
        - N桁の2進数Xを受け取って、i桁目のbitを反転したときのf(X)をすべて求める
        - N <= 1e5
    - 解法
        - popcount(n) はO(logn)なので、一回popcount(n)のあまりが作れたらその後は再帰で良い
        - s = popcount(n)とすると、各桁のbit反転したやつのpopcountはs+1 or s-1
        - X % pは、桁ごとに2^i % p を足していけば求まるので、X % s+1, X % s-1を先に求めておく
        - 下からi桁が
            - 1だったら、X % s-1 - 2^i 
            - 0だったら、X % s+1 + 2^i
            - があまり
        - そこから再帰で適当にf(n)を求める
        - sが1だと、s-1が0になって嫌な感じになるのでケアする。
    - その他
        - f(n) は O(slog n) 
            - slog -> 超対数というらしい。
            - https://ja.wikipedia.org/wiki/%E3%83%86%E3%83%88%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3
        
- E	Camel Train
    - 概要
        - 要素N個を並び替える
        - 要素iは左からKiまでにいたら、Li、そうでなかったらRiのスコア
        - スコアの最大化
        - N <= 1e5
    - 嘘解法
        - 大きい方から、BITでkiに足して、Ki以下がi個以上だったら入れられない。みたいな
        - 3,3,3,1みたいに来られたときに、3以下のやつが3個あるので1は入れられない、みたいなケースをカバーできなかったので、嘘 
    - 解法
        - L>Rのやつが左側、そうでないのが右側になるような並びが最適になる
        - それぞれ独立に考えられる
        - k=1から、入れられるやつをpqに入れて、pqが常にk以下になるようにする。
        - 初めにRを足して、k以下に入れられるならl-r足すのが楽。
        - ABC137Dと発想同じだし、解けたなぁ。。
        
- F	Two Snuke
    - 概要
        - 条件
            - x1+x2+x3+x4+x5+y1+y2+y3+y4+y5 <= N
            - xi > 0, yi > xi
        - 上記を満たすx1,x2,x3,x4,x5,y1,y2,y3,y4,y5のすべての選び方に対して、
        - (y1-x1)\*(y2-x2)\*..\*(y5-x5)の和 
        - N <= 1e9
    - 公式解説
        - y1-x1のかたちだと嫌なので、y1-x1 =s1とする
            - x1 + y1 -> 2*x1 + s1
            - 2*x1 = t1とする 
        - s1+t1+....+s5+t5 <= N となるs,tの組み合わせで、s1 \* s2 \* ... \* s5の和
        - s1+t1+....+s5+t5 <= Nは、
            - N個のボールを10個の仕切りで分ける方法 N+10 C 10
        - また、s1 \* s2 \* ... \* s5は、s1,s2,...,s5に対応する仕切りから一つ選ぶのに対応する。
        - つまり、N-5個のボールを、15個の仕切りで分ける方法に対応する。
            - ここの発想天才。~の組み合わせでの~の和を、~の組み合わせだけにできた
        - 面倒なのが、s1,s2,...,s5は偶数でないといけないという制約があるので、DPっぽいのをしないといけない
        - でNが大きいのでO(N)は無理なので、行列累乗で高速化
        - dp[i][j] : i番目までみて、j個仕切りを入れている。見ている仕切りが偶数にならないといけないのを管理
        - 行列累乗について、解説
            - https://www.hamayanhamayan.com/entry/2020/07/12/100318

    - 別解1
        - https://betrue12.hateblo.jp/entry/2020/07/12/060026
            - めっちゃわかりやすい
        - x1+x2+...+x5 = xとすると s1+s2+...+s5 <= N - 2x となる
            - xの中の組み合わせは、4個の仕切りを入れるので nCk(x+4, 4)
            - 後半は、N-2x-5個から仕切りを10個入れるので、nCk(N-2x+5, 10)
        - つまり、答えは
            - f(N) = sum_{x=0..float(N-5/2)} nCk(x+4, 4) * nCk(N-2x+5, 10)
        - f(N)のsumの中はxの14次の多項式
        - つまり、f(N)は15次の多項式
        - 16通りのNに対して、f(N)を求めれば、ラグランジュ補間により任意のNに対してf(N)が計算可能
        - すごい
    - 別解2
        - 形式的べき級数解法
        - 正直良くわからん
        - https://maspypy.com/atcoder-%E5%8F%82%E5%8A%A0%E6%84%9F%E6%83%B3-2020-07-11%E3%82%A8%E3%82%A4%E3%82%B7%E3%83%B3%E3%82%B0-%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0-%E3%82%B3%E3%83%B3%E3%83%86
        - https://www.hamayanhamayan.com/entry/2020/07/12/100318

    - 別解3
        - noimiついーと
            - https://twitter.com/noimi_kyopro/status/1281947146757926912
        - 解説
            - https://www.youtube.com/watch?v=lJD5dQ8OZ5k
        - コード
            - https://atcoder.jp/contests/aising2020/submissions/15209244
        - 公式解法で、s1..5が偶数じゃないといけないって言ってるところ、
        - 15個の仕切りに分けられた16箇所、全部偶数じゃないといけないという成約にする
        - ただ、ホントは後半の11箇所は奇数でもいいので、奇数とするところは、最後に1足す。
        - 11箇所のうち、奇数の数でループしながら、どこが奇数になるかをnCk(11, i)でかける
        - 天才
        
## Atcoder Regular Contest

### ARC012

- C - 五目並べチェッカー
    - 概要
        - 五目並べとしてあり得る盤面かどうかを判定
    - 解法
        - 黒、白の数があっていて
        - 最後に打たれた色の石を一個ずつ取り除いてみて、その盤面が終了してないかどうかを見れば良い。


### ARC110 (鹿島建設プログラミングコンテスト2020)

- A	Redundant Redundancy
    - 概要
        - 2,3,...,N  のどれで割っても 1 余る、N 以上 1013 以下の整数を出力
    - 解法
        - なぜか素因数分解してmapでがんばってしまったが、
        - lcmを随時計算させればよかった。アホ。
        
- B	Many 110
    - 概要
        - 110を1e10連結した文字列に、Tが何個含まれるか
    - 解法
        - 110の何文字目からTがはじまるかと、Tの文字数をごにょごにょする
        
- C	Exoswap
    - 概要
        - 各位置をちょうど1回ずつswapすることで、数列のソートをすることができるか
    - 解法
        - 無駄に頑張ってしまった
        - 数列の各要素の正しい位置までの差を管理して、
        - 右に行きたい人と左に行きたい人が並んでたらswapする。
        - swapする候補は最初に列挙して、その後はswapしたまわりを候補に追加する
        - なんか、合わなくて最後ごまかしてしまったので嘘かもしれない。
    - 公式
        - 大事な気付きとして、1は必ず一番左まで持っていって良い。
        - この時点でもともと1があったところまでのidxでswapは完了しているので、そこまでは並んでないとだめ
        - そのidx以降で最小値を探して、左まで持ってく、を繰り返す
        
- D	Binomial Coefficient is Fun
    - 概要
        - 長さNの数列A[N]が与えられる
        - 長さNで、和がM以下の非負数列B全てに対する Π nCk(B[i], A[i]) の和 
    - 解法
        - 実験エスパー系。めっちゃむずかった。
        - Π nCk(B[i], A[i])の意味を考える
            - B[i]の箱の中にA[i]個のボールを入れる組み合わせの積
        - S=sum(A)として、
        - M+N個の箱があって、S+N個の詰める組み合わせを考えると、
        - この計算で求まりそう。というのがわかるので、
        - なんとnCk(M+N, S+N)で終わり。
    - その他
        - https://drken1215.hatenablog.com/entry/2020/12/06/070100
            - 格子の経路数に帰着。こっちのほうがわかりやすいかも

### ARC111

- A	Simple Math 2
    - 概要
        - floor(10^N / M) % M　を答える
    - 解法
        - X = floor(10^N / M)
        - Y = X % M
        - 10^N = M * X + A
        - X = M * B + Y
        - 10^N = M^2 * B + M * Y + A
        - 求めるのはYなので、10^NをM^2で割ったあまり、をMで割った商
        
- B	Reversible Cards
    - 概要
        - N枚のカードの表裏にそれぞれ整数
        - いい感じに表裏を決めて、表に現れる整数の種類数の最大値
    - 解法
        - 普通にむずかった。
        - 整数をノードとして、各カードを辺とする。
        - 各辺の片方のノードを光らせることができて、光るノードの数。
        - 連結のグラフが木だとすると、根以外全部光らせられることがわかる
        - また、木じゃなければ、サイクルとなっているところのどれかを根とくっつけられる。
        - そんな感じで数えられる。
        
- C	Too Heavy
    - 概要
        - 人iの体重がA[i], 荷物jの重さがB[j]
        - はじめ、人iは荷物P[i]を所持
        - 人iが荷物iを持つようにするための最小のswap回数
        - ただし、人は自分の体重以上の荷物を持った状態ではswapできない
    - 解法
        - 制約がない場合、swap回数は、サイクルの数をCとするとN-C回
            - 1つのサイクル内で、そろってないやつから合わせに行けばよく、最後一人は勝手に揃ってる
            - ので、サイクルがあるごとに1回減るので
        - 各サイクルにおいて、体重が一番軽い人から合わせに行くとすると、体重が軽い人が持ってるやつは、次の人は必ず持てる
        - つまり、これを続けていけばN−C回を実現できる。
        - 初手の時点でA[i]<B[i]だったらできないので弾く。
            - ただ、変えなくていい場合は問題ない
            - 全部変えなくていいわけではなく、サイクルの一つが変えなくていい場合を漏らしてた。
            

## Atcoder Regular Contest Like

### NOMURA プログラミングコンテスト 2020

- C	Folia
    - 概要
        - 深さNの2分木で、各深さの葉の枚数が指定される
        - 制約を満たしつつ、木の頂点数が大きくなるようにしたときの頂点数
    - 解法
        - できるだけ同じ親から２つ生やすのではなく、異なる親から１個ずつ生やしたほうが頂点は多くなる
        - 上から見てくと、葉の下に子が作れないので、次の深さに作れる頂点の最大値が決まる
        - 適当にやってくとできる
    - 反省
        - ばかすぎて、最初の取れる最大を求めるところで2^dの計算してるのにオーバーフローに気づかなかった。ばかすぎ。****
- D	Urban Planning
    - 概要
    - 解法
- E	Binary Programming
    - 概要
    - 解法
- F	Sorting Game

### 東京海上日動 プログラミングコンテスト2020
- C	Lamps
    - 概要
        - 電球N個が数直線上のある座標Xiにある
        - 電球iは、左右にA[i]照らす
        - 1stepで、A[i]は、iを照らす電球の数になる(自分を含む)
        - K step後のA[i]
    - 解法
        - 普通に考えるとめっちゃむずい
        - やってくと、大体A[i]は2倍くらいになることがわかる。
        - また、最終的にずっと続けたら、全電球が全電球を照らすので、A[i]=Nになる
        - つまり、O(logN)くらいで、最終状態になるので、
        - 普通にループ回して最終状態になったら終わればOK




## Atcoder Grand Contest

### agc014

- B : Unplanned Queries
    - 概要
        - 木のa-bのパスの辺に+1する、という操作をいくつかする
        - 全ての辺が偶数となるように木を構築できるか
    - 解法
        - クエリ a-b　は、根をrとすると r-a と r-b　に分解できる。
            - a-b = a-lca + lca-b 
            - r-a + r-b =  a-lca + lca-r + r-lca + lca-b = a-lca + lca-b
        - よって、r-vのパスに+1するという操作 f(v) が2M回行われるということ
        - 全クエリ中で、f(v)のvとして現れる回数が奇数だったら、絶対に奇数の辺ができる。
        - ので、結局、a-bとして現れる頂点の回数を数えて遇数のみならYes、そうでないならNO
       
### agc044

- A - Pay to Win
    - 概要
        - 数字X=0をNにする
        - 2倍, 3倍, 5倍, ±1, の操作をするのにコストがA,B,C,Dかかる
        - 最小のコスト
    - 解法
        - 普通にむずくてわからんかった。
        - A,B,C,Dの大小関係がまったくないので、考えるのは不可能
        - ちょっと工夫した全探索でできる
            - 19 -> 15 -> 3 -> 2と、19 -> 10 -> 2という操作を見た時、
            - 19 -> 10まで言ってからわざわざ2で割る必要は絶対ない。
            - つまり、nから、近い2,3,5の倍数のどれかに言って、2,3,5で割る、という操作のどれかが最適、とわかる
            - ここで気をつけるのが、割らずにそのまま-1し続けるのが最適な場合がある。D <<<< A,B,Cの場合がそう。
        - つまり、dfsに入力されるのは2^a * 3^b * 5^cの数字のどれかなので、いける

- B - Joker
    - 概要
        - N*Nのマスに人がいて、左上から1〜右上がN*Nのidx
        - i番目にP[i]の人が、マスの外側に出る。
        - 出る時、人がいるマスを通るとコスト1
        - すべての人が出るときのコストの総和
    - 解法
        - 各人がその時に外に出るまでのコストD[i][j]を常に管理する
        - 誰かが出ると、その周辺の人のコストが下がる可能性がある。
            - また、それによって下がった人の周りも、下がる可能性がある
        - つまり、下がった人をqueueに入れて、取り出して周りを下げられるなら下げて、コストに入れる。をする
            - 抜けた人のコストも一応管理する必要があって、抜けたかどうかのフラグは管理する必要がある
            - 抜けたところを使う場合は+0, そうじゃない場合は+1なので
        - 計算量解析がこの問題の肝
            - パット見BFSがO(N^2)でそれをN^2回やりそうな気がする
            - queueに入れる回数を考えてみると、
            - queueに入れたらコストの総和が1減ることがわかる
            - つまり、queueに入れる回数はO(コストの総和)、
            - コストの総和は、各コストが最大でもN/2であることを考えるとO(N^3)
            - つまり、queueに入れるのはO(N^3)なので、全体の計算量もO(N^3)
          
      
### agc045

- A : Xor Battle
    - 概要
        - 人0, 人1がいる
        - A[N], S[N]が与えられる
        - x = 0で初期化されて、各iで、
            - 人S[i]が x = x とするか、x ^= A[i]を選べる
        - 人0はx=0にしたい。人1は x!=1にできる
        - 最適にそれぞれ行動したら、x=0 or x!=0どちらか
        - N <= 200
    - 解法
        - 最初、順番関係なくて、それぞれ作れる数があって、人1に作れて人0に作れない数があればOKかと思ったが、
          人0が最後にごちゃごちゃやってできちゃうことがある
        - dp[i] = i番目にx=tだったらその後、x=0にできるようなtの集合
        - これをi=Nから逆順にやっていく
        - 普通にやると、dp[i]の要素数は2^Nとかになるので、無理
        - ここで、基底だけ考える、という発想
            - 1000, 0100, 0010, 0001があれば、2^4-1までは全部作れるよね、的な発想。
            - ので、dp[i]で管理するのは基底だけにする。
            - 各iで、今までの基底で作れないやつが来た時、
                - 人0の番だったら、基底が増える
                - 人1の番だったら、それ以降で人はそれを作れないので、x!=0になる
            - 基底の求め方は掃き出し法を普通にやってもいいのだが、
            - for (auto b: basis){ x = min(x, x^b);} で各回で求めたいものが計算できる
                - 基底は、今までもってるやつのどれよりもmsbが立ってる場所が小さいのでこれで求まる
                
### agc046

- A	Takahashikun, The Strider
    - 概要
        - ある点から1m進み、x度回転する.
        - 何回進んだら原点に戻るか
    - 解法
        - k*xが360の倍数となる最小のkが答え
        
- B Extension
    - 概要
        - A * Bのマスがあって、全部白
        - (A+1)*B か、A*(B+1)にして、追加したマスのどれか一つを黒く塗る
        - C * Dにするときの塗り方の数え上げ
    - 解法
        - dp[x][y]: x*yのときの塗り方の通り
        - x * yにするには、x-1,y or x,y-1からのどちらかからしかない。
        - それぞれ、y, xの塗り方があるが、一部ダブルカウントしてしまう。
        - ダブルカウントしてしまうのは、x-1,y-1のところに一つずつ黒がある場合
        - これは(x-1)*(y-1)*dp[x-1][y-1]なので、これを引けばいい。
    - 想定解法
        - かたっぽの塗り方を全部考えて、それでは塗れないのを、もうかたっぽで埋める発想
            - x,yの一番上の行に、複数塗れるのは、x-1から来た場合のみ。
            - 1個しか塗らないのは、y-1から来るのでできる。的な
            
- C	Shift    
    - 概要
        - 011100110
        - みたいな0,1からなる文字列
        - 1を0の一つ左に持ってく操作を、K回以下行ってできる文字列の通り
    - 解法
        - まずは、0で区切って1の数で、考える。one[N0+1]とする
            - 例なら0,3,0,2,0
        - 左に持っていく、少し考えづらいので、反転して右に持っていくにする
            - 例なら、0,2,0,3,0
        - dp[i][j][k]
            - i番目まで見て
            - j回操作してて、
            - k個右に持って来てるような場合の数
        - これでいいという理解
            - 左から、iに持ってきてまたそれを右にくばる、みたいなことは無意味
            - から、j回操作したうちのj-k個はiの左側で移動が完結している
            - 怪しいけどこんな感じで一意に定まっている気がする
        - O(N^4)解 (配るDP)
            - dp[i][j][k]から遷移できるのは
                1. 操作をして、iから右に配る。kが増える。
                    - 増やせるのはone[i]だけ。
                2. 操作をせず、kのいくつかをiにおいてく。kが減る。
                    - すでに操作をして左から持ってきている状態なので、操作回数は増えない
        - O(N^3)解 (もらうDP)
            - dp[i][j][k]に遷移できるのは、
                - Kより多い状態から、iに落とす
                    - dp[i+1][j][k] = dp[i][j][k] + dp[i][j][k+1] + .. + dp[i][j][K]
                    - k=Kから逆順にたどれば、累積和になるのでO(1)でdp[i][j][k]が計算できる
                - Kより少ない状態から、i個目を右に持っていってKになる
                    - dp[i+1][j][k] = dp[i][j-1][k-1] + dp[i][j-2][k-2] + .. + dp[i][j-ones[i]][k-ones[i]]]
                    - cumsum[i][j] = cumsum[i-1][j-1] + dp[i-1][j-1]しておいて、
                    - 累積和の差で、O(1)で計算できる
        - 良い問題だった
    - 参考
        - https://betrue12.hateblo.jp/entry/2020/06/21/175355
          

## PAST

### Past02

- 他の人の参加機
    - https://rsk0315.hatenablog.com/entry/2020/05/02/181650

- A	エレベーター
    - 概要
        - B9~1Fまでの階
        - 2つの階が文字列で与えられて、2つの階の差
    - 解法
        -  特になし
        
- B	多数決
    - 概要
        - 文字列でa,b,cの3つの中で一番多いもの
    - 解法
        - 3つif分愚直に書いたが、{'a',0}, {'b',1}, {'c',2}のvector<P>
        - maxとったほうが良さそう (a,b,cの数で一番大きいのが一つだけという制約だから)

- C	山崩し
    - 概要
        - あるルールで文字列書き換えるだけ
    - 解法
        - 適当にシミュレート
         
- D	パターンマッチ
    - 概要
        - 与えられた文字列の、部分文字列(3文字以下)を列挙
        - .を使う場合は一致してなくてもOK
    - 解法
        - 27^3をスライドするだけ
        
- E	順列
    - 概要
        - 置換を処理する 
    - 解法
        - ABC166 D I hate Factorizationと同じ。
        - 今までみたことがあるかどうかの配列を、何個目のループのやつかの配列を同じにすると良い
          
- F	タスクの消化
    - 概要
        - j日目から開始できてポイントがBiのタスクがN個
        - K日で達成できるタスクの総和の最大値
    - 解法
        - (j, B[i])のペアでソートして、
        - 開始できるようになってから順番に取り出して、priority_queueにつっこんで1個取り出す。
        - をK回繰り返したらOK
        
- G	ストリング・クエリ
    - 概要
        - 文字CiをXi個先頭に追加
        - 文字をDi個削除
            - その時にどの文字が何個消えたかを出力
    - 解法
        - 愚直に足していくとXiがでかいので無理
        - (Ci, Xi)をdequeで管理
        
- H	1-9 Grid
    - 概要
        - グリッドに1~9に数字がかかれていて、
        - S->Gまで、1~9の順番で通って到着する最短経路
            - 同じ数字、小さい数字を何回通っても良い
    - 解法
        - N*M*dを状態にして、(d=0~9, d=0はまだ1を通ってない状態) ダイクストラ 
        
- I	トーナメント
    - 概要
        - 2^Nの出場者がいつ負けるか
    - 解法
        - 頑張って木っぽく管理したが、普通に配列作り直して管理したほうが良かった
        
- J	文字列解析
    - 概要
        - x(abc)y -> xabccbay
        - みたいに()内をa + rev(a)で置換する
    - 解法
        - ()が内包してることがあるので再帰でがんばる
        
- K	括弧
    - 概要
        - 括弧からなる文字列
        - i番目をひっくり返すのにCi  )->(, or (->) 
        - i番目を消すのにDi
    - 解法
        - この辺から少し考えないといけない
        - dp[i][j] : i番目まで見て、( がj個開いている状態の最小のコスト
            - )を追加するとjが減る
            - 削除するとjは同じ
            - (を追加するとjが増える
        - で解ける 
        
- L	辞書順最小
    - 概要
        - 数字をKを選ぶ
        - 選ぶときは、i - j >= Dでないといけない。
        - 辞書順最小のものを選ぶ
    - 解法
        - 後ろからD*(K-1)+1個より前じゃないと、K個選べなくなる
        - また、数字が一番小さいやつを選ぶのが明らかに良い
        - かつ、同じ数字でも前の方を選んだほうが絶対良い
        - ので、選べる範囲で最小値を選んでいけば良い
        - mine
            - 選べる範囲からの最小値を脳死でセグ木で拾った
        - 想定回
            - 選べる範囲は、lが最後に撮った要素で、rは1個取るごとにD個後ろに行くので
            - もうちょいしょぼいのでも良い
        
- M	食堂
    - 概要
        - 食堂では、D日周期で、Ci ~ Cdのメニューが出る
        - 社員iは、以下の条件のとき食堂に行く
            - 初日Fi
            - メニューが好物Kiの日
            - 最後に食堂に言ってからL日目 (これは全社員共通)
        - 社員iがTi回食堂に行くまでに好物Kiを何回食べるかを出力
    - 解法
        - すげえ実装時間かかった。。。。
        - ...○●..●...○ みたいな感じ
        - あるメニューCiが好物の社員が、1週で何回食堂に行くかは予めわかる
        - 各社員iについて
            - Fi日目から一番近い好物まで移動
                - この時、各好物のindexのリストを持っておいてにぶたん
            - 1週で何回食堂に行くか、かつ何回好物を食べるかをカウント
                - これも覚えておく
            - Tiのあまりを処理
                - j個好物を食べるのに何回食堂に行く必要があるかをにぶたん
                - バグ: このとき、Fi日目から一番近い好物が2週目の可能性もあり、実装的には3週分持ってないとバグる
                - 改善: ばかすぎて何個目から探す必要があるかを管理する必要がある気がして、
                    - next(a.begin(), idx)からnext(a.begin(), idx+num)みたいにここ以降で探す、みたいにしちゃった
                    - 結局全部昇順だから、a.begin(), a.end()でも出てくるインデックス同じだわ。
        - 2,3時間位実装にかかった。。。。死にたい
    - 想定回
        - https://atcoder.jp/contests/past202004-open/submissions/13623696
        - ダブリングで求めておいたほうが簡単
        - 各メニューからその2^k回先まで同じメニューの日に遷移した場合に、
            - 食堂を何回利用するか
            - どこにいるか
        - を覚えておくといい感じ   
                                                     
- N	ビルの建設
    - 概要
        - x,x+d,y,y+d敷地iがN個
            - 重なりもある。コストがCi
        - x,yの位置に建物をおいたときのコスト
            - x,yを含む敷地のコストの総和
    - 解法
        - 平面走査法というやつ
        - 敷地と建物ををxでソート
        - 建物を一つずつ取り出して見ていく。
            - 建物のxより左にある敷地を、順番に処理する
            - y軸方向を座標圧縮して、遅延セグ木でCiを区間addしていく。
            - x+dも同様に管理して、x+dが左側に来たらCiを引く
            - 建物のyの場所のsumを拾えればOK
       -  座標圧縮、平面走査、遅延セグ木、となかなか色々知ってる必要があるやつでこれは嬉しい
    - その他
        - 遅延セグ木でなぐったが、BITでも区間addと値の取得ならできる
        - xも座標圧縮して、二次元セグ木、BITでも殴れるらしい。
            - https://math.nakaken88.com/problem/atcoder-past-202004-n/
            
- O	可変全域木
    - 概要
        - 無向グラフで、各辺を使用した際の最小値全域木のコストの和
    - 解法
        - AOJ2559のちょっと簡単版
        - まず最小全域木Tを普通に計算
        - Tに使われてない辺i(u,vをつなぐ)をTに追加すると、閉路ができる
        - その閉路上、つまり、u-vパス上の辺ならどれを消しても全域木のまま
        - u-vパス上の辺の中で最大の辺がわかればOK
            - HL分解してセグ木を乗せて、最大値を計算する。
    - 想定回1
        - 並列二分探索
            - https://betrue12.hateblo.jp/entry/2019/08/14/152227
            - 使えるケース
                - ある操作をN回行う
                    - 例えば集合の併合など、簡単に戻せないやつ
                - ある状態になったのは、操作を何回した時点か、的なクエリがQ回
                    - 例えばある要素と要素が併合されているかどうか、など。
                    - ある時点以降は成り立つような性質のもの
            - 普通にクエリに対して毎回1から操作をN回やると O(NQ)
            - ある時点以降成り立つなら、二分探索がやりたいが、aを調べたあとにbを調べるためには操作を(b-a)回やらないといけないし、戻すのは大変なので、個別には回せない
            - そこで、クエリQ個を並列に行う二分探索を行う
            - それぞれのクエリ用の、inf, supを個別に持っておく。
            - 最初にmidを計算しておいて、操作を1~Nまで回しながら、誰かのmidと一致したら、それの評価を行って、inf, supの更新を行う。
            - こうすると、操作Nを回す操作は二分探索の回数分なので、logで抑えられる。
            - さらに、各ループで、各クエリは1回ずつしか評価しないので、
            - 最終的な計算量は O( logA * (N + Q))に抑えられる。すごい。
        - 適用方法
            - 操作
                - コスト最小の辺から順にUnionFindで連結する
            - クエリ
                - u,vが連結するのはどの時点か
            - 詳細
                - この操作を繰り返すと、いつかu,vは連結する。
                    - コスト最小の辺から順番に連結しているので、
                    連結した瞬間にたされた辺は、u,vをつなぐために必要な辺の中で重みが最大
                - つまり、i回目にu,vが連結したなら、u-vパス上の最大の辺は、M[i]だとわかる
                - で、UnionFindは不可逆で、かつこの評価は単調性があるので並列二分探索でいける
        - コード
            - https://atcoder.jp/contests/past202004-open/submissions/12577084
            - 読みやすい
            
    - 想定回2
        - ダブリング
        - u, vパスの最大の重みを計算するために、
            - 2^i 個上の先祖の番号
            - 2^i 個上の先祖に至るまでの辺の重みの最大値
        - をそれぞれダブリングで求めると、u,vパスの最大重みをlogNで求めることができる
        - HL分解してセグ木とまぁにてるが、こっちのほうが軽そう。

### Past03


- G	グリッド金移動
    - 概要
        - 無限のグリッドに、いくつか障害物
        - 6通りの移動(上下と右下右上)
        - 最小
    - 解法
        - ダイクストラ
        - 一応大きめのグリッドを用意しないと一番外側の障害物の外を通る場合があるのでケア
        
- H	ハードル走
    - 概要
        - 1, 3, 5個飛べる。それぞれT1, T2, T3かかる
        - 障害物は3,5でとばないといけない
        - ゴールは、空中にいても良い
    - 解法
        - DP
        - 最後の超えるところを気をつけないと
        
- I	行列操作
    - 概要
        - 行列のswap, transpose, query
    - 解法
        - 行、列をがんばって処理する。
        - transposeは行と列をswap
        
- J	回転寿司
    - 概要
        - 子供がN人並んでる
        - 寿司が左から流れて、
            - 今まで食べたものより美味しいもの寿司なら食べる
            - そうでないなら後ろに
        - それぞれの寿司が誰に食べられるか
    - 解法
        - LIS
        - 格納されるindexが答え
        
- K	コンテナの移動
    - 概要
        - 机iにコンテナiがある
        - クエリがQ個
            - コンテナiを、上にあるコンテナも含めて机jのコンテナの上におく
    - 解法
        - 机iのtop, コンテナjの下にあるコンテナのidx, (link)を持っておき
        - コンテナiを、上にあるコンテナも含めて机jのコンテナの上におく
            - link[j] = top[i]
            - top[j] = top[i]
            - top[i] = link[j]
            
- L	スーパーマーケット
    - 概要
        - N行の配列があり、i行目はKi個の要素
        - クエリがM個
            - 各行の先頭のうち最も大きいもの
            - 各行の先頭とその次のうち最も大きいもの
            - を削除して、それを答える
    - 解法
        - 先頭、先頭とその次を含めたpqを用意してガチャガチャ
    - 想定解
        - 先頭、その次のpqのほうが実装楽だわ
        
- M	行商計画問題
    - 概要
        - N頂点、M辺のグラフ
        - sから初めて、特定のK個の頂点すべてを通る最短経路
        - N, M <= 1e5 K <= 16
    - 解法
        - K+1個の頂点 (始点を含む)同士をダイクストラで最短経路をすべて求める
        - すると、巡回セールスマン問題になるので、2^K+1の状態を持ってダイクストラ
        
- N	入れ替えと並び替え
    - 概要
        - 配列A[N]
        - クエリがQ個
            - 1. A[x], A[x+1]をswap
            - 2. A[x..y]をsort
        - クエリQ回後のAを出力
    - 解法
        - 重要な考察として、5回swapしたものをsortするのは5回のswapでいける
        - 1回のswapで、転倒数の増減は1
        - クエリ1によって、高々Q回しか転倒数は増えない。
        - A[i] > A[i+1]となっているiの場所を管理しておけば、sort時にswapしないといけない回数はQ回以下
        - swapすると、i-1, i, i+1の3箇所で、右との大小関係が変わる可能性があるので3箇所チェックしておく

    - 大事
        - この問題のように，データのある種の複雑さを表す値を取って，その値が「増えた分しか減らせない」
          ことを利用してデータに対する操作の計算量を償却する方法は，データ構造のポテンシャルを用いた解析
          と呼ばれています。
        - らしい。
        
- O	輪投げ
    - 概要
        - M個のボールを、N個の箱のどれかに入れる。1ラウンドに一つの箱には一つまで
        - これを3ラウンド
        - ラウンドiでi個目の箱にボールを入れると(Aj * Bj^i) % Riのスコア
        - 3ラウンド終わったときに、箱に入ったボールの個数をkとするとAj * Bj^kのスコア分マイナス
    - 解法
        - DP行けそうに見えてめっちゃむずい
        - 最小費用流でいける
            - 流量3*Mを流す
            - 頂点は、s, ラウンド分の3個, N個の箱,t 
            - N個の箱から終点に、
                - ボールがk個だったときのマイナス分をPkとすると、
                - Pk - Pk-1を入れる。
                - ここが少しむずい
                - 常にPk - Pk-1 > Pk-1 - Pk-2なので、N個の頂点からこれを3辺張っても、kが一番小さいのが選択される
