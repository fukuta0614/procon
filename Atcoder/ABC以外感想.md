

## Atcoder Regular Contest


### NOMURA プログラミングコンテスト 2020

- C	Folia
    - 概要
        - 深さNの2分木で、各深さの葉の枚数が指定される
        - 制約を満たしつつ、木の頂点数が大きくなるようにしたときの頂点数
    - 解法
        - できるだけ同じ親から２つ生やすのではなく、異なる親から１個ずつ生やしたほうが頂点は多くなる
        - 上から見てくと、葉の下に子が作れないので、次の深さに作れる頂点の最大値が決まる
        - 適当にやってくとできる
    - 反省
        - ばかすぎて、最初の取れる最大を求めるところで2^dの計算してるのにオーバーフローに気づかなかった。ばかすぎ。****
- D	Urban Planning
    - 概要
    - 解法
- E	Binary Programming
    - 概要
    - 解法
- F	Sorting Game

### 東京海上日動 プログラミングコンテスト2020
- C	Lamps
    - 概要
        - 電球N個が数直線上のある座標Xiにある
        - 電球iは、左右にA[i]照らす
        - 1stepで、A[i]は、iを照らす電球の数になる(自分を含む)
        - K step後のA[i]
    - 解法
        - 普通に考えるとめっちゃむずい
        - やってくと、大体A[i]は2倍くらいになることがわかる。
        - また、最終的にずっと続けたら、全電球が全電球を照らすので、A[i]=Nになる
        - つまり、O(logN)くらいで、最終状態になるので、
        - 普通にループ回して最終状態になったら終わればOK
 

## Atcoder Grand Contest

### agc014

- B : Unplanned Queries
    - 概要
        - 木のa-bのパスの辺に+1する、という操作をいくつかする
        - 全ての辺が偶数となるように木を構築できるか
    - 解法
        - クエリ a-b　は、根をrとすると r-a と r-b　に分解できる。
            - a-b = a-lca + lca-b 
            - r-a + r-b =  a-lca + lca-r + r-lca + lca-b = a-lca + lca-b
        - よって、r-vのパスに+1するという操作 f(v) が2M回行われるということ
        - 全クエリ中で、f(v)のvとして現れる回数が奇数だったら、絶対に奇数の辺ができる。
        - ので、結局、a-bとして現れる頂点の回数を数えて遇数のみならYes、そうでないならNO
       
### agc044

- A - Pay to Win
    - 概要
        - 数字X=0をNにする
        - 2倍, 3倍, 5倍, ±1, の操作をするのにコストがA,B,C,Dかかる
        - 最小のコスト
    - 解法
        - 普通にむずくてわからんかった。
        - A,B,C,Dの大小関係がまったくないので、考えるのは不可能
        - ちょっと工夫した全探索でできる
            - 19 -> 15 -> 3 -> 2と、19 -> 10 -> 2という操作を見た時、
            - 19 -> 10まで言ってからわざわざ2で割る必要は絶対ない。
            - つまり、nから、近い2,3,5の倍数のどれかに言って、2,3,5で割る、という操作のどれかが最適、とわかる
            - ここで気をつけるのが、割らずにそのまま-1し続けるのが最適な場合がある。D <<<< A,B,Cの場合がそう。
        - つまり、dfsに入力されるのは2^a * 3^b * 5^cの数字のどれかなので、いける

- B - Joker
    - 概要
        - N*Nのマスに人がいて、左上から1〜右上がN*Nのidx
        - i番目にP[i]の人が、マスの外側に出る。
        - 出る時、人がいるマスを通るとコスト1
        - すべての人が出るときのコストの総和
    - 解法
        - 各人がその時に外に出るまでのコストD[i][j]を常に管理する
        - 誰かが出ると、その周辺の人のコストが下がる可能性がある。
            - また、それによって下がった人の周りも、下がる可能性がある
        - つまり、下がった人をqueueに入れて、取り出して周りを下げられるなら下げて、コストに入れる。をする
            - 抜けた人のコストも一応管理する必要があって、抜けたかどうかのフラグは管理する必要がある
            - 抜けたところを使う場合は+0, そうじゃない場合は+1なので
        - 計算量解析がこの問題の肝
            - パット見BFSがO(N^2)でそれをN^2回やりそうな気がする
            - queueに入れる回数を考えてみると、
            - queueに入れたらコストの総和が1減ることがわかる
            - つまり、queueに入れる回数はO(コストの総和)、
            - コストの総和は、各コストが最大でもN/2であることを考えるとO(N^3)
            - つまり、queueに入れるのはO(N^3)なので、全体の計算量もO(N^3)
                
### agc045

- A : Xor Battle
    - 概要
        - 人0, 人1がいる
        - A[N], S[N]が与えられる
        - x = 0で初期化されて、各iで、
            - 人S[i]が x = x とするか、x ^= A[i]を選べる
        - 人0はx=0にしたい。人1は x!=1にできる
        - 最適にそれぞれ行動したら、x=0 or x!=0どちらか
        - N <= 200
    - 解法
        - 最初、順番関係なくて、それぞれ作れる数があって、人1に作れて人0に作れない数があればOKかと思ったが、
          人0が最後にごちゃごちゃやってできちゃうことがある
        - dp[i] = i番目にx=tだったらその後、x=0にできるようなtの集合
        - これをi=Nから逆順にやっていく
        - 普通にやると、dp[i]の要素数は2^Nとかになるので、無理
        - ここで、基底だけ考える、という発想
            - 1000, 0100, 0010, 0001があれば、2^4-1までは全部作れるよね、的な発想。
            - ので、dp[i]で管理するのは基底だけにする。
            - 各iで、今までの基底で作れないやつが来た時、
                - 人0の番だったら、基底が増える
                - 人1の番だったら、それ以降で人はそれを作れないので、x!=0になる
            - 基底の求め方は掃き出し法を普通にやってもいいのだが、
            - for (auto b: basis){ x = min(x, x^b);} で各回で求めたいものが計算できる
                - 基底は、今までもってるやつのどれよりもmsbが立ってる場所が小さいのでこれで求まる
                
### agc046

- A	Takahashikun, The Strider
    - 概要
        - ある点から1m進み、x度回転する.
        - 何回進んだら原点に戻るか
    - 解法
        - k*xが360の倍数となる最小のkが答え
        
- B Extension
    - 概要
        - A * Bのマスがあって、全部白
        - (A+1)*B か、A*(B+1)にして、追加したマスのどれか一つを黒く塗る
        - C * Dにするときの塗り方の数え上げ
    - 解法
        - dp[x][y]: x*yのときの塗り方の通り
        - x * yにするには、x-1,y or x,y-1からのどちらかからしかない。
        - それぞれ、y, xの塗り方があるが、一部ダブルカウントしてしまう。
        - ダブルカウントしてしまうのは、x-1,y-1のところに一つずつ黒がある場合
        - これは(x-1)*(y-1)*dp[x-1][y-1]なので、これを引けばいい。
    - 想定解法
        - かたっぽの塗り方を全部考えて、それでは塗れないのを、もうかたっぽで埋める発想
            - x,yの一番上の行に、複数塗れるのは、x-1から来た場合のみ。
            - 1個しか塗らないのは、y-1から来るのでできる。的な
            
- C	Shift    
    - 概要
        - 011100110
        - みたいな0,1からなる文字列
        - 1を0の一つ左に持ってく操作を、K回以下行ってできる文字列の通り
    - 解法
        - まずは、0で区切って1の数で、考える。one[N0+1]とする
            - 例なら0,3,0,2,0
        - 左に持っていく、少し考えづらいので、反転して右に持っていくにする
            - 例なら、0,2,0,3,0
        - dp[i][j][k]
            - i番目まで見て
            - j回操作してて、
            - k個右に持って来てるような場合の数
        - これでいいという理解
            - 左から、iに持ってきてまたそれを右にくばる、みたいなことは無意味
            - から、j回操作したうちのj-k個はiの左側で移動が完結している
            - 怪しいけどこんな感じで一意に定まっている気がする
        - O(N^4)解 (配るDP)
            - dp[i][j][k]から遷移できるのは
                1. 操作をして、iから右に配る。kが増える。
                    - 増やせるのはone[i]だけ。
                2. 操作をせず、kのいくつかをiにおいてく。kが減る。
                    - すでに操作をして左から持ってきている状態なので、操作回数は増えない
        - O(N^3)解 (もらうDP)
            - dp[i][j][k]に遷移できるのは、
                - Kより多い状態から、iに落とす
                    - dp[i+1][j][k] = dp[i][j][k] + dp[i][j][k+1] + .. + dp[i][j][K]
                    - k=Kから逆順にたどれば、累積和になるのでO(1)でdp[i][j][k]が計算できる
                - Kより少ない状態から、i個目を右に持っていってKになる
                    - dp[i+1][j][k] = dp[i][j-1][k-1] + dp[i][j-2][k-2] + .. + dp[i][j-ones[i]][k-ones[i]]]
                    - cumsum[i][j] = cumsum[i-1][j-1] + dp[i-1][j-1]しておいて、
                    - 累積和の差で、O(1)で計算できる
        - 良い問題だった
    - 参考
        - https://betrue12.hateblo.jp/entry/2020/06/21/175355
          

### Past02

- 他の人の参加機
    - https://rsk0315.hatenablog.com/entry/2020/05/02/181650

- A	エレベーター
    - 概要
        - B9~1Fまでの階
        - 2つの階が文字列で与えられて、2つの階の差
    - 解法
        -  特になし
        
- B	多数決
    - 概要
        - 文字列でa,b,cの3つの中で一番多いもの
    - 解法
        - 3つif分愚直に書いたが、{'a',0}, {'b',1}, {'c',2}のvector<P>
        - maxとったほうが良さそう (a,b,cの数で一番大きいのが一つだけという制約だから)

- C	山崩し
    - 概要
        - あるルールで文字列書き換えるだけ
    - 解法
        - 適当にシミュレート
         
- D	パターンマッチ
    - 概要
        - 与えられた文字列の、部分文字列(3文字以下)を列挙
        - .を使う場合は一致してなくてもOK
    - 解法
        - 27^3をスライドするだけ
        
- E	順列
    - 概要
        - 置換を処理する 
    - 解法
        - ABC166 D I hate Factorizationと同じ。
        - 今までみたことがあるかどうかの配列を、何個目のループのやつかの配列を同じにすると良い
          
- F	タスクの消化
    - 概要
        - j日目から開始できてポイントがBiのタスクがN個
        - K日で達成できるタスクの総和の最大値
    - 解法
        - (j, B[i])のペアでソートして、
        - 開始できるようになってから順番に取り出して、priority_queueにつっこんで1個取り出す。
        - をK回繰り返したらOK
        
- G	ストリング・クエリ
    - 概要
        - 文字CiをXi個先頭に追加
        - 文字をDi個削除
            - その時にどの文字が何個消えたかを出力
    - 解法
        - 愚直に足していくとXiがでかいので無理
        - (Ci, Xi)をdequeで管理
        
- H	1-9 Grid
    - 概要
        - グリッドに1~9に数字がかかれていて、
        - S->Gまで、1~9の順番で通って到着する最短経路
            - 同じ数字、小さい数字を何回通っても良い
    - 解法
        - N*M*dを状態にして、(d=0~9, d=0はまだ1を通ってない状態) ダイクストラ 
        
- I	トーナメント
    - 概要
        - 2^Nの出場者がいつ負けるか
    - 解法
        - 頑張って木っぽく管理したが、普通に配列作り直して管理したほうが良かった
        
- J	文字列解析
    - 概要
        - x(abc)y -> xabccbay
        - みたいに()内をa + rev(a)で置換する
    - 解法
        - ()が内包してることがあるので再帰でがんばる
        
- K	括弧
    - 概要
        - 括弧からなる文字列
        - i番目をひっくり返すのにCi  )->(, or (->) 
        - i番目を消すのにDi
    - 解法
        - この辺から少し考えないといけない
        - dp[i][j] : i番目まで見て、( がj個開いている状態の最小のコスト
            - )を追加するとjが減る
            - 削除するとjは同じ
            - (を追加するとjが増える
        - で解ける 
        
- L	辞書順最小
    - 概要
        - 数字をKを選ぶ
        - 選ぶときは、i - j >= Dでないといけない。
        - 辞書順最小のものを選ぶ
    - 解法
        - 後ろからD*(K-1)+1個より前じゃないと、K個選べなくなる
        - また、数字が一番小さいやつを選ぶのが明らかに良い
        - かつ、同じ数字でも前の方を選んだほうが絶対良い
        - ので、選べる範囲で最小値を選んでいけば良い
        - mine
            - 選べる範囲からの最小値を脳死でセグ木で拾った
        - 想定回
            - 選べる範囲は、lが最後に撮った要素で、rは1個取るごとにD個後ろに行くので
            - もうちょいしょぼいのでも良い
        
- M	食堂
    - 概要
        - 食堂では、D日周期で、Ci ~ Cdのメニューが出る
        - 社員iは、以下の条件のとき食堂に行く
            - 初日Fi
            - メニューが好物Kiの日
            - 最後に食堂に言ってからL日目 (これは全社員共通)
        - 社員iがTi回食堂に行くまでに好物Kiを何回食べるかを出力
    - 解法
        - すげえ実装時間かかった。。。。
        - ...○●..●...○ みたいな感じ
        - あるメニューCiが好物の社員が、1週で何回食堂に行くかは予めわかる
        - 各社員iについて
            - Fi日目から一番近い好物まで移動
                - この時、各好物のindexのリストを持っておいてにぶたん
            - 1週で何回食堂に行くか、かつ何回好物を食べるかをカウント
                - これも覚えておく
            - Tiのあまりを処理
                - j個好物を食べるのに何回食堂に行く必要があるかをにぶたん
                - バグ: このとき、Fi日目から一番近い好物が2週目の可能性もあり、実装的には3週分持ってないとバグる
                - 改善: ばかすぎて何個目から探す必要があるかを管理する必要がある気がして、
                    - next(a.begin(), idx)からnext(a.begin(), idx+num)みたいにここ以降で探す、みたいにしちゃった
                    - 結局全部昇順だから、a.begin(), a.end()でも出てくるインデックス同じだわ。
        - 2,3時間位実装にかかった。。。。死にたい
    - 想定回
        - https://atcoder.jp/contests/past202004-open/submissions/13623696
        - ダブリングで求めておいたほうが簡単
        - 各メニューからその2^k回先まで同じメニューの日に遷移した場合に、
            - 食堂を何回利用するか
            - どこにいるか
        - を覚えておくといい感じ   
                                                     
- N	ビルの建設
    - 概要
        - x,x+d,y,y+d敷地iがN個
            - 重なりもある。コストがCi
        - x,yの位置に建物をおいたときのコスト
            - x,yを含む敷地のコストの総和
    - 解法
        - 平面走査法というやつ
        - 敷地と建物ををxでソート
        - 建物を一つずつ取り出して見ていく。
            - 建物のxより左にある敷地を、順番に処理する
            - y軸方向を座標圧縮して、遅延セグ木でCiを区間addしていく。
            - x+dも同様に管理して、x+dが左側に来たらCiを引く
            - 建物のyの場所のsumを拾えればOK
       -  座標圧縮、平面走査、遅延セグ木、となかなか色々知ってる必要があるやつでこれは嬉しい
    - その他
        - 遅延セグ木でなぐったが、BITでも区間addと値の取得ならできる
        - xも座標圧縮して、二次元セグ木、BITでも殴れるらしい。
            - https://math.nakaken88.com/problem/atcoder-past-202004-n/
            
- O	可変全域木
    - 概要
        - 無向グラフで、各辺を使用した際の最小値全域木のコストの和
    - 解法
        - AOJ2559のちょっと簡単版
        - まず最小全域木Tを普通に計算
        - Tに使われてない辺i(u,vをつなぐ)をTに追加すると、閉路ができる
        - その閉路上、つまり、u-vパス上の辺ならどれを消しても全域木のまま
        - u-vパス上の辺の中で最大の辺がわかればOK
            - HL分解してセグ木を乗せて、最大値を計算する。
    - 想定回1
        - 並列二分探索
            - https://betrue12.hateblo.jp/entry/2019/08/14/152227
            - 使えるケース
                - ある操作をN回行う
                    - 例えば集合の併合など、簡単に戻せないやつ
                - ある状態になったのは、操作を何回した時点か、的なクエリがQ回
                    - 例えばある要素と要素が併合されているかどうか、など。
                    - ある時点以降は成り立つような性質のもの
            - 普通にクエリに対して毎回1から操作をN回やると O(NQ)
            - ある時点以降成り立つなら、二分探索がやりたいが、aを調べたあとにbを調べるためには操作を(b-a)回やらないといけないし、戻すのは大変なので、個別には回せない
            - そこで、クエリQ個を並列に行う二分探索を行う
            - それぞれのクエリ用の、inf, supを個別に持っておく。
            - 最初にmidを計算しておいて、操作を1~Nまで回しながら、誰かのmidと一致したら、それの評価を行って、inf, supの更新を行う。
            - こうすると、操作Nを回す操作は二分探索の回数分なので、logで抑えられる。
            - さらに、各ループで、各クエリは1回ずつしか評価しないので、
            - 最終的な計算量は O( logA * (N + Q))に抑えられる。すごい。
        - 適用方法
            - 操作
                - コスト最小の辺から順にUnionFindで連結する
            - クエリ
                - u,vが連結するのはどの時点か
            - 詳細
                - この操作を繰り返すと、いつかu,vは連結する。
                    - コスト最小の辺から順番に連結しているので、
                    連結した瞬間にたされた辺は、u,vをつなぐために必要な辺の中で重みが最大
                - つまり、i回目にu,vが連結したなら、u-vパス上の最大の辺は、M[i]だとわかる
                - で、UnionFindは不可逆で、かつこの評価は単調性があるので並列二分探索でいける
        - コード
            - https://atcoder.jp/contests/past202004-open/submissions/12577084
            - 読みやすい
            
    - 想定回2
        - ダブリング
        - u, vパスの最大の重みを計算するために、
            - 2^i 個上の先祖の番号
            - 2^i 個上の先祖に至るまでの辺の重みの最大値
        - をそれぞれダブリングで求めると、u,vパスの最大重みをlogNで求めることができる
        - HL分解してセグ木とまぁにてるが、こっちのほうが軽そう。

### Past03


- G	グリッド金移動
    - 概要
        - 無限のグリッドに、いくつか障害物
        - 6通りの移動(上下と右下右上)
        - 最小
    - 解法
        - ダイクストラ
        - 一応大きめのグリッドを用意しないと一番外側の障害物の外を通る場合があるのでケア
        
- H	ハードル走
    - 概要
        - 1, 3, 5個飛べる。それぞれT1, T2, T3かかる
        - 障害物は3,5でとばないといけない
        - ゴールは、空中にいても良い
    - 解法
        - DP
        - 最後の超えるところを気をつけないと
        
- I	行列操作
    - 概要
        - 行列のswap, transpose, query
    - 解法
        - 行、列をがんばって処理する。
        - transposeは行と列をswap
        
- J	回転寿司
    - 概要
        - 子供がN人並んでる
        - 寿司が左から流れて、
            - 今まで食べたものより美味しいもの寿司なら食べる
            - そうでないなら後ろに
        - それぞれの寿司が誰に食べられるか
    - 解法
        - LIS
        - 格納されるindexが答え
        
- K	コンテナの移動
    - 概要
        - 机iにコンテナiがある
        - クエリがQ個
            - コンテナiを、上にあるコンテナも含めて机jのコンテナの上におく
    - 解法
        - 机iのtop, コンテナjの下にあるコンテナのidx, (link)を持っておき
        - コンテナiを、上にあるコンテナも含めて机jのコンテナの上におく
            - link[j] = top[i]
            - top[j] = top[i]
            - top[i] = link[j]
            
- L	スーパーマーケット
    - 概要
    - 解法
- M	行商計画問題
    - 概要
    - 解法
- N	入れ替えと並び替え
    - 概要
    - 解法
- O	輪投げ
    - 概要
    - 解法