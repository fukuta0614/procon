## 練習

- 二分探索
bisect

-  フェルマーの小定理
$a^p$ ≡ a (mod p)
$a^{p-1}$ ≡ 1 (mod p)

- mを法とする場合での除算
A ÷ B = C で、それぞれmod をとってa, b, cだとすると、
a * (bの逆元) ≡ c
逆元は b-1 = b**(p-2)で与えられる

- リストのスライシングはO(N)かかるからクソ

- 水たまり問題
スタックをうまく使う

- 番兵による線形探索
配列のおわりに答えをおいて、while文でiをincrementすること探索中の比較を1回で住むように

- RMQ
平行分割、セグメント木、BIT

---------- 
## abc001
- python3の四捨五入
round関数はくそ (切り捨て誤差が小さくなるように偶数になってしまう）
round(2.5) -> 2
小数点がずれて怖いときは、評価する方を掛け算してあげる
1123 -> 1120 にしたいとき t -= t % 5
- いもす法
立ち上がりに1、立ち下がりに-1を入れておいて、最後累積和を取ることで >0 なら雨、==0なら晴れになる

## abc002
- 最大クリーク問題
    1. 所詮N = 12だから2**12で回す
    2. クリーク数決めてcombinationであるかないか、というのを友達の数でmaxとって二分探索
    3. for i in range(N) 友達増やしてみて現在の友達全員と友達かどうかを判定
    
## abc003
- 包除原理
結構めんどかった. 
たてよこ、たてよこの組み合わせ6通り、 たてよこ３つ選んだとき、たてよこ全部
(1, 2, 3, 4) - (0, 1, 3, 6) + (0, 0, 1, 4) + (0, 0, 0, 2)
それぞれありうるかどうかの条件も必要

## abc004
- マーブル
時間かかった。できるだけ関数は再利用していこう

## abc005
- imos法
N+1*N+1の配列を作っておけばindexが-1の例外処理がいらなくなる

## abc006
- LIS

## abc007
- 桁DP

## abc008
- コイン裏表の枚数の期待値
約数を数え上げ、左側に約数が奇数枚くる確率を計算、確率がそのまま期待値になる。賢い
- 金塊ゲーム
メモ化再帰サイコ〜

## abc009
- 漸化式は行列の累乗を利用することでO(logn)で解ける！
- AND、XORを足し算掛け算のように扱う (半環)

## abc010
- ある点から他の点に何処か寄り道してから向かうという問題で、移動距離Lが決まっている場合楕円内にある点にならいける
- Dめちゃむずかった
marked girlのそれぞれの後ろにもう一つノードを設け、ログインできなくする工作をそのノードを切ると見なしそれぞれの工作をまとめる
最小カット最大フロー定理
ford-fulkersonのアルゴリズム
    - 適当に流す。流した流量をdとすると、流した方向のエッジに重みdを足し、逆方向を向くエッジ(capacity 0)に-dを足す (残余ネットワーク)
    - 流せなくなるまで続ける

## abc011
- 貪欲法
- combinationはパスカルの三角形使うと良いらしい

## abc012
- ワーシャルフロイドはpython通らない

## abc013
- 満腹な高橋くん(下からDP、順番関係ないからXによってのみほかが決まる)
- 巡回置換 
巡回の操作も累乗の足し算作戦
リストの削除普通にやると死ぬほど遅いので二分探索

## abc014
- 最小共通祖先 (LCA)
- pythonきびしいな〜

## abc015
- ナップザック亜種
後ろからループ回すことで品物数のループをする際メモリを使いまわせる

## abc016
- 交点問題
直線を挟んで逆側にあるか -> 外積の積が負
線分内に交点があるか、両端からみて外積の積が負

## abc017
- 宝石と魔王ゲーム
imos法
- サプリメント
dp & imos法　難しかった
dp(i) にはi番目のサプリを食べおわったときの組み合わせ

## abc018
- ひし形カウント 難しかった ある方向に関して両側開いてるマス数を保存しておく
- 半分全列挙

## abc019
- 木の直径
ある点（なんでも良い）から一番遠い点xからみて一番遠い点yとすると、x-yの距離が直径

## abc020
- ダイクストラ & 二分探索
- 最大公倍数の列挙 むずかった

## abc021
- DAGの数え上げ ダイクストラで最短経路出してからメモ化再帰
queue突っ込んだ順に取り出す方式なら、初めて通ったノードは確実に最短経路 
二回目以降は、最短経路と同じなら足す
- nHr

## abc022
- 最短閉路
閉路はスタートのノードを除けば経路になる 
ワーシャルフロイドで全点対最短距離を求めておいて、スタートに接続するノードを２つ選ぶ 
$O(N^3) + O(N^2)$ \\
ダイクストラで最短経路木求めながらスタートから生える枝にIDをつける
最短閉路は
ある枝の途中からスタートに帰ってくる場
ある枝から他の枝に移動して返ってくる場合のどれか
$O(N^2)$
- 天体の膨張
平行移動、回転によって影響を受けない距離の比を考える
全天体の距離の総和、最近点の長さ、最遠点の長さ、重心からの最近点、最遠点の距離

## abc023
- 収集王
縦横の和がある数字に まとめてから
- 射撃王
最小化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

## abc024
- 民族大移動
貪欲法
- フェルマーの小定理

## abc025
- ゲーム木探索
- 25個の整数
最高に難しかった

## abc026
- 数値計算の二分探索

## abc027
- ロボット
ある時刻において右に動いた場合の将来的な収支は計算できる
高い順に並べて低いところで左に行けばいい

## abc028
- 特になし

## abc029
- 特になし

## abc030
- 特になし

## abc031
- 語呂合わせ
文字数先に決めてしまって確認

## abc032
- ある積以下の最長部分列
1 1は積に影響しないのでまとめる, 10**9は実は掛け算だとO(logN)だからそんな大したことない 
2 尺取法 O(N)
3 logとると和になるので、累積和が使える。長さｘを二分探索 O(NlogN) (誤差めんどくさそう）
4 現在の最大の長さ以下の探索はしなくてよいので、尺取法において一つ減らすだけで良い
- ナップサック
価値でDP
n少ないがW,Vに上限がない場合 ２つに分けて全組み合わせ列挙 -> いらないのはぶいてそれぞれいい感じに突き合わせる（二分探索）

## abc033
- abc簡単
- 鈍角、直角三角形
よくわからなかった

## abc034
- (n-1)^1+1
- 最大化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

## abc035
- 有向グラフにおける行きと帰りの最短距離 -> 帰りは矢印を逆にしてダイクストラ

## abc036
- treeDP
いい問題だった。自分が白の組み合わせと、どちらでもいい組み合わせの漸化式

## abc037
- pythonおせえ〜

## abc038
- BIT, LIS
(i&-i) で rightmost set bit だけ取り出せる

## abc039
- 特になし

## abc040
- union-find木

## abc041
- bitDP, 2**nのDP

## abc042
- 行けない場所があるときのグリッドの経路組み合わせ

## abc043
- アンバランス

## abc044
- 選んだ合計の平均がA -> それぞれの要素を x - A とすると合計が0になればいい

## abc052
- N!の約数の総数
- 
