## 備忘録


## 基本

-  フェルマーの小定理
$a^p$ ≡ a (mod p)
$a^{p-1}$ ≡ 1 (mod p)

- mを法とする場合での除算
A ÷ B = C で、それぞれmod をとってa, b, cだとすると、
a * (bの逆元) ≡ c
逆元は b-1 = b**(p-2)で与えられる

- 水たまり問題
スタックをうまく使う

- 番兵による線形探索
配列のおわりに答えをおいて、while文でiをincrementすること探索中の比較を1回で住むように

### セグメント木
- 木に関するテクニック集  
https://topcoder.g.hatena.ne.jp/iwiwi/20111205/1323099376

- 理解  
要素とそれをマージする演算がモノイドなら適用可能  
モノイド->演算が結合律を持ち、単位元が存在する
(f(f(a・b)・c) = f(a・f(b・c))であればよく、f(a・e)=aとなるeがいればいい)  
https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html  
http://beet-aizu.hatenablog.com/entry/2019/03/12/171221
 
- 遅延セグ木  
作用素の適用が可換なら伝播させる必要はホントはない。
ex. [a, b) をxにする、は可換でないので伝播させないとだめ。


---------- 
## abc001
- python3の四捨五入
round関数はくそ (切り捨て誤差が小さくなるように偶数になってしまう）
round(2.5) -> 2
小数点がずれて怖いときは、評価する方を掛け算してあげる
1123 -> 1120 にしたいとき t -= t % 5
- いもす法
立ち上がりに1、立ち下がりに-1を入れておいて、最後累積和を取ることで >0 なら雨、==0なら晴れになる

## abc002
- 最大クリーク問題
    1. 所詮N = 12だから2**12で回す
    2. クリーク数決めてcombinationであるかないか、というのを友達の数でmaxとって二分探索
    3. for i in range(N) 友達増やしてみて現在の友達全員と友達かどうかを判定
    
## abc003
- 包除原理
結構めんどかった. 
たてよこ、たてよこの組み合わせ6通り、 たてよこ３つ選んだとき、たてよこ全部
(1, 2, 3, 4) - (0, 1, 3, 6) + (0, 0, 1, 4) + (0, 0, 0, 2)
それぞれありうるかどうかの条件も必要

## abc004
- マーブル
時間かかった。できるだけ関数は再利用していこう

## abc005
- imos法
N+1*N+1の配列を作っておけばindexが-1の例外処理がいらなくなる

## abc006
- LIS

## abc007
- 桁DP

## abc008
- コイン裏表の枚数の期待値
約数を数え上げ、左側に約数が奇数枚くる確率を計算、確率がそのまま期待値になる。賢い
- 金塊ゲーム
メモ化再帰サイコ〜

## abc009
- 漸化式は行列の累乗を利用することでO(logn)で解ける！
- AND、XORを足し算掛け算のように扱う (半環)

## abc010
- ある点から他の点に何処か寄り道してから向かうという問題で、移動距離Lが決まっている場合楕円内にある点にならいける
- Dめちゃむずかった
marked girlのそれぞれの後ろにもう一つノードを設け、ログインできなくする工作をそのノードを切ると見なしそれぞれの工作をまとめる
最小カット最大フロー定理
ford-fulkersonのアルゴリズム
    - 適当に流す。流した流量をdとすると、流した方向のエッジに重みdを足し、逆方向を向くエッジ(capacity 0)に-dを足す (残余ネットワーク)
    - 流せなくなるまで続ける

## abc011
- 貪欲法
- combinationはパスカルの三角形使うと良いらしい

## abc012
- ワーシャルフロイドはpython通らない

## abc013
- 満腹な高橋くん(下からDP、順番関係ないからXによってのみほかが決まる)
- 巡回置換 
巡回の操作も累乗の足し算作戦
リストの削除普通にやると死ぬほど遅いので二分探索

## abc014
- 最小共通祖先 (LCA)
- pythonきびしいな〜

## abc015
- ナップザック亜種
後ろからループ回すことで品物数のループをする際メモリを使いまわせる

## abc016
- 交点問題
直線を挟んで逆側にあるか -> 外積の積が負
線分内に交点があるか、両端からみて外積の積が負

## abc017
- 宝石と魔王ゲーム
imos法
- サプリメント
dp & imos法　難しかった
dp(i) にはi番目のサプリを食べおわったときの組み合わせ

## abc018
- ひし形カウント 難しかった ある方向に関して両側開いてるマス数を保存しておく
- 半分全列挙

## abc019
- 木の直径
ある点（なんでも良い）から一番遠い点xからみて一番遠い点yとすると、x-yの距離が直径

## abc020
- ダイクストラ & 二分探索
- 最大公倍数の列挙 むずかった

## abc021
- DAGの数え上げ ダイクストラで最短経路出してからメモ化再帰
queue突っ込んだ順に取り出す方式なら、初めて通ったノードは確実に最短経路 
二回目以降は、最短経路と同じなら足す
- nHr

## abc022
- 最短閉路
閉路はスタートのノードを除けば経路になる 
ワーシャルフロイドで全点対最短距離を求めておいて、スタートに接続するノードを２つ選ぶ 
$O(N^3) + O(N^2)$ \\
ダイクストラで最短経路木求めながらスタートから生える枝にIDをつける
最短閉路は
ある枝の途中からスタートに帰ってくる場
ある枝から他の枝に移動して返ってくる場合のどれか
$O(N^2)$
- 天体の膨張
平行移動、回転によって影響を受けない距離の比を考える
全天体の距離の総和、最近点の長さ、最遠点の長さ、重心からの最近点、最遠点の距離

## abc023
- 収集王
縦横の和がある数字に まとめてから
- 射撃王
最小化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

## abc024
- 民族大移動
貪欲法
- フェルマーの小定理

## abc025
- ゲーム木探索
- 25個の整数
最高に難しかった

## abc026
- 数値計算の二分探索

## abc027
- ロボット
ある時刻において右に動いた場合の将来的な収支は計算できる
高い順に並べて低いところで左に行けばいい

## abc028
- 特になし

## abc029
- 特になし

## abc030
- 特になし

## abc031
- 語呂合わせ
文字数先に決めてしまって確認

## abc032
- ある積以下の最長部分列
1 1は積に影響しないのでまとめる, 10**9は実は掛け算だとO(logN)だからそんな大したことない 
2 尺取法 O(N)
3 logとると和になるので、累積和が使える。長さｘを二分探索 O(NlogN) (誤差めんどくさそう）
4 現在の最大の長さ以下の探索はしなくてよいので、尺取法において一つ減らすだけで良い
- ナップサック
価値でDP
n少ないがW,Vに上限がない場合 ２つに分けて全組み合わせ列挙 -> いらないのはぶいてそれぞれいい感じに突き合わせる（二分探索）

## abc033
- abc簡単
- 鈍角、直角三角形
よくわからなかった

## abc034
- (n-1)^1+1
- 最大化問題を直接解くのではなく、あるxが条件を満たすかを確認、xを二分探索

## abc035
- 有向グラフにおける行きと帰りの最短距離 -> 帰りは矢印を逆にしてダイクストラ

## abc036
- treeDP
いい問題だった。自分が白の組み合わせと、どちらでもいい組み合わせの漸化式

## abc037
- pythonおせえ〜

## abc038
- BIT, LIS
(i&-i) で rightmost set bit だけ取り出せる

## abc039
- 特になし

## abc040
- union-find木

## abc041
- bitDP, 2**nのDP

## abc042
- 行けない場所があるときのグリッドの経路組み合わせ

## abc043
- アンバランス

## abc044
- 選んだ合計の平均がA -> それぞれの要素を x - A とすると合計が0になればいい

## abc052
- N!の約数の総数
- 

## aribon 2-3-4
- 高橋くんゲーム  
基本的には0-1ナップザックの価値でdpして重みの最小値を求めていくタイプと一緒。  
問題の指定はちょうどK回という制約があるが、実際にはK回以下でn日勝率upできるなら、K回でも達成できること。
肝は、一回負けて以降、全勝すればK回になる。（分母が大きくなれば勝率は上がる）

## aribon 2-3-5
- D - Many Go Round  
個数制限DP。一周するので配列再利用ができない。

- フクロモモンガ  
普通にダイクストラでやってしまった。何がDPかまだわからず。  
あみだとは違い、どこからでも移動できるので最適な移動が簡単に決まる。  
とりあえず下まで降りていって、降りられなくなったらその分登る。
そうすると、結局ある地点まで最短時間でたどり着くやつがえらいので、それをコストにダイクストラ  

- Bichrome Tree  
面白かった。
結局、自分の子供の、自分の色じゃない方の和は小さいほどよいので、
取りうる組み合わせの和のなかで最小値を求めれば良い。  
その取りうる組み合わせが最悪2^Nになるので、DPで求める。

- 注文の多い高橋商店  
mada


## aribon 2-3-6
- インラインDP  
NQのdpテーブル更新が必要に見えるが、実際にはQ回行う更新ではNの中の一箇所しか更新しない場合、
logN・Qに落とせること。  
LISはある長さの最長増加部分列の最後尾の数だけ更新すれば良くて、それが二部探索でlogNで探せる。的な


## aribon 2-3-7
- 写像12相  
    - N個のボールを、K個の箱に入れる組み合わせで、  
    - Nを区別するか、Kを区別するか、(条件あり、単射、全射）の12個の組み合わせのこと  
    - その中に、スターリング数、ベル数、分割数がある

- 分割数  
    - 正の整数nをm分割するときの場合の数。  
    - dp[i][j] : jのi分割
    - 0を一つでも含むときdp[i-1][j]と、0を含まないときdp[i][j-i]の和

- Kill/Death  
    - dp[i][j] : i番目まで見たときの、総和がjとなる組み合わせ  
    - dp[i+1][j+sm] = dp[i][j] * (smのグループ人数 分割)) これのsmのiteration   
    - すごい解法: https://kimiyuki.net/writeup/algo/atcoder/dwacon2018-prelims-c/

## aribon 3-1 値の検索だけじゃない！ "二分探索"

### 例題 3-1-1
- ARC 037 C 億マス計算 
    - 

### 例題 3-1-2
- 

### 例題 3-1-3
- JOI 2013 本選 C バームクーヘン
    - 
    
### 例題 3-1-4
- ARC 060 C 高橋君とカード
    - N枚のカードを複数選んで平均がちょうどAになるような選び方
    - 各カードからAを引いて和が0になるような選び方にする
    - dp[i][j] = i番目まで使うとき、和がjになるような選び方の総数 
    
- ARC 075 E Meaningful Mean
    - N個の配列の連続部分列のなかで算術平均がk以上となる数
    - median of mediansの部分問題
    - 
    - std::sortは安定ソートでないため、順序を変えたくなかったらstable_sortを使う

## aribon 3-2 厳選！頻出テクニック

### 例題 3-2-1 しゃくとり 
- ARC 098 D Xor Sum 2
    - A_l + ... + A_r = A_l xor ... xor A_r　となる連続部分列の数
    - 和とxorが一致するのは、bitごとにみたときに1が複数立たないとき
    - lからrまで見て成り立っていればその中の連続部分列は全部OK
    - つまり尺取法
 
### 例題 3-2-2 しゃくとり応用
- ABC 033 D 三角形の分類
    - 
    
### 例題 3-2-3 ライツアウト
- ABC 083 D Wide Flip
    - 意外とむずかった
    

### 例題 3-2-4 ライツアウト応用
- AOJ 1308 Awkward Lights
    - マンションのある部屋のスイッチを消すと、マンハッタン距離Dの部屋のon/offが変化
    - 同じ部屋のスイッチを二回押す必要はなく、スイッチを押す順は関係ない
    - 連立方程式

### 例題 3-2-5 弾性衝突
- SRM 458 DIV1 Easy BouncingBalls

### 例題 3-2-6 半分全列挙
- ダーツ
    - N個の配列から4つ取り出したときの和のM以下の最大値
    - 2つ取り出した場合の取りうる値を保持してにぶたん

### 例題 3-2-7 半分全列挙 応用
- AGC 026 C - String Coloring
    - 2Nの文字列のうちNを青色、Nを赤色に塗り分けたとき、青と赤の文字列が一致するような塗り方の組み合わせ
    - 左半分のNの青と赤の分割方法、右半分のNの青と赤の分割方法、それぞれ2^N通りを列挙して辞書につっこんで、突き合わせる
    - ABC 049 D 連結にやや似てる
    

### 例題 3-2-8 座標圧縮
- 領域の個数
    - 疎なかたまりがあるような二次元座標でラベリング
    - 何もないところを圧縮
    - 1234 789となっていたとき、56のところになにもないからといって7を5まで圧縮すると
   つながってしまうので、はじっこの±1分は圧縮しないよう気をつける
  
- JOI 2008 予選 E シャッフル
    - 山札があって、a,bのクエリをもらったら上からa枚目までと、b+1枚目から一番下までを交換する
    - 例題とはちょっと様子が違うけど、10枚で3,5のクエリなら、
    - [1,10] -> [1,3],[4,5],[6-10] -> [6-10],[4,5],[1,3]
    - みたいな感じで、分割して、シャッフルする、みたいな感じ

## aribon 3-3 BITとセグ木

### 例題 3-3-1 セグ木
- Crane  
    - むずい。コードは理解はしたがこれじゃないといけないのかわかってない

- タコヤキオイシクナール  
    - 良問。f(x) = ax+b, g(x) = cx + d -> f・g(x) = (ac)x + b+ad なのでモノイド

- JOI 2011 春合宿 day4-2 本棚  
    - 昇順にするには、増加部分列を見つけてそれ以外を動かせば良い。  
    - 動かすやつの重さの和が小さければ良いので、最大重み増加部分列を求める  
    - 末尾がxのときの最大の重みを計算できればよく、[a,b)のmaxが計算できればOK

### 例題 3-3-2 BIT
- ARC 088 E Papple Sort  
    - 文字列を回文にするためのスワップ回数  
    - 最終的に左側に来る必要があるか右側に来る必要があるかは確定している。
    - 肝は、左側を1回swap, 右側を1回swapしてできるなら 右側を2回swapでできるので、
    左側は動かす必要ないため、左側の最終状態も確定する。  
    - 右側を左側にするためのswap回数 -> 転倒数カウントでOK

### 例題 3-3-3 遅延セグ木

- AOJ Course RSQ and RAQ  
    - 区間addと区間sum。
    - 遅延セグ木で簡単だが、伝播させなくてもできる。(区間addが可換だから)

- AOJ Course RMQ and RAQ  
    - 区間addと区間max。Starry Sky Tree。
    - 遅延セグ木で簡単だが、伝播させなくてもできる。(区間addが可換だから)

### 例題 3-3-4 平方分割
- K-th Number (POJ No.2104)  
    - 配列の区間[a,b)の小さい方からk番目の数を答えるクエリを高速に
    - 平方分割
        - 各バケットごとにソートしておく。各バケット内にxより小さい数が何個あるかはにぶたんでいけて、
        xをにぶたんすればok。はみ出した部分はソート前のoriginal配列で線形探索。
    - RangeTreeでもいける
        - 各ノードはマージソートしたときの中間結果(配列)を保持しているイメージ。
        - 区間[a,b)を上から見てひっかかったノードでにぶたんすれば、xより小さい数を数えられる  
        -> 二次元座標でl<=x<rでかつ y<tなる点の数を数えることも可能
- ARC 033 C データ構造
    - 集合にxを追加, x番目に小さい数を求めて集合から削除　のクエリを高速に
    - aがはいる箱を用意して、aが追加されたらa番目を+1するほうが楽
    - 平方分割なら、箱を分割して箱ごとに今何個入っているかも管理すれば楽。       


## aribon 3-7 GCJ の問題に挑戦してみよう

- Numbers  
(3 + √5)^n の整数部分をもとめる  
(3 + √5)^n =  an + √5 bn  
(3 - √5)^n =  an - √5 bn  がわかる
3 - √5 < 1なので、整数部分は 2 * an - 1とわかる
anを求めるために、行列累乗。繰り返し二乗法で行ける。




 